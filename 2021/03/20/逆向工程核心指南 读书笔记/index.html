<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;dark&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png"><link rel="icon" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="John Doe"><meta name="keywords" content=""><title>逆向工程核心指南 读书笔记 - KillAragorn&#39;s Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css"><link rel="stylesheet" href="/css/main.css"><script id="fluid-configs">var Fluid=window.Fluid||{},CONFIG={hostname:"example.com",root:"/",version:"1.8.9",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},copy_btn:!0,image_zoom:{enable:!0},toc:{enable:!0,headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,baidu:"https://hm.baidu.com/hm.js?ac869ccd147869a461a862e3e2b3e282",google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null}}}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><header style="height:100vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>KillAragorn's Blog</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner" id="banner" parallax="true" style="background:url(/img/aier.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="page-header text-center fade-in-up"><span class="h2" id="subtitle" title="逆向工程核心指南 读书笔记"></span><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-03-20 14:10" pubdate>2021年3月20日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 40 分钟</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto"><h1 style="display:none">逆向工程核心指南 读书笔记</h1><p class="note note-info">本文最后更新于：17 天前</p><div class="markdown-body"><h2 id="chapter-5-栈"><a href="#chapter-5-栈" class="headerlink" title="chapter 5:栈"></a>chapter 5:栈</h2><h3 id="栈的增长方向"><a href="#栈的增长方向" class="headerlink" title="栈的增长方向"></a>栈的增长方向</h3><ol><li>在x86体系结构中，栈是逆增长的，指的是 push xxx 这条指令，esp、rsp 的值会减小对应的值，而arm 体系结构中，栈可以是递增也可以是递减的</li><li>栈的逆增长和历史有关，程序中同时存在堆和栈，两者都可以增长，那么具体增长到多少是无法提前确定的，所以将栈设计为逆增长，类似于一个笔记本记录两门课的笔记，一门从前往后去记，一门从后往前记</li></ol><h3 id="栈的用途"><a href="#栈的用途" class="headerlink" title="栈的用途"></a>栈的用途</h3><ol><li>保存函数的返回地址</li><li>参数传递<ol><li>具体参数的地址要根据函数的调用约定来确定</li></ol></li><li>存储局部变量</li><li>alloca函数直接使用栈来分配内存</li><li>windows seh 结构化异常处理</li><li>缓冲区溢出保护</li></ol><h3 id="典型的栈的内存存储格式"><a href="#典型的栈的内存存储格式" class="headerlink" title="典型的栈的内存存储格式"></a>典型的栈的内存存储格式</h3><p>在32位中，在程序调用函数之后，执行它的第一条指令之前，栈在内存中的布局格式如下。</p><table><thead><tr><th>———————-</th><th></th></tr></thead><tbody><tr><td>esp - c</td><td>第二个局部变量，ida中记为var_8</td></tr><tr><td>esp - 8</td><td>第一个局部变量，ida中记为var_4</td></tr><tr><td>esp - 4</td><td>保存的ebp 的值</td></tr><tr><td>esp</td><td>返回地址</td></tr><tr><td>esp + 4</td><td>arg1，ida中记为arg_0</td></tr><tr><td>esp + 8</td><td>arg2，ida中记为arg_4</td></tr><tr><td>esp + c</td><td>arg3，ida中记为arg_8</td></tr></tbody></table><h3 id="栈的对齐粒度"><a href="#栈的对齐粒度" class="headerlink" title="栈的对齐粒度"></a>栈的对齐粒度</h3><ul><li><p>在32位程序中，编译器编译的代码一般对栈是8字节对齐，但在64位程序中，编译器编译出来的代码对栈一般是16字节对齐，一个函数调用另一个函数时，因为压入的8字节返回地址，使本来对齐16字节的栈不对齐了，所以一般在函数开头有使栈对齐16字节的指令</p></li><li><p>[详细解释看这]: <a target="_blank" rel="noopener" href="http://www.cpu2.net/stackalign.html">http://www.cpu2.net/stackalign.html</a></p></li></ul><h2 id="chapter-6-参数传递"><a href="#chapter-6-参数传递" class="headerlink" title="chapter 6: 参数传递"></a>chapter 6: 参数传递</h2><h3 id="x86：传递3个参数"><a href="#x86：传递3个参数" class="headerlink" title="x86：传递3个参数"></a>x86：传递3个参数</h3><ol><li>msvc 2010<ol><li>使用push 来向栈中传递参数</li></ol></li><li>gcc 4.4.1<ol><li>先使用sub 来开辟栈空间，再使用mov 来直接操作栈中的数据</li></ol></li></ol><h3 id="x64：传递9个参数测试"><a href="#x64：传递9个参数测试" class="headerlink" title="x64：传递9个参数测试"></a>x64：传递9个参数测试</h3><ol><li><p>msvc 2010 2019</p><ol><li><p>debug <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142923.png" srcset="/img/loading.gif" lazyload></p></li><li><p>release：这种情况编译器保证传参的位置是对的，不保证传参的顺序，同时使用lea代替mov，表明编译器认为lea执行的比mov更有效率</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142924.png" srcset="/img/loading.gif" lazyload alt="image-20210106150523272"></p><ul><li><p>在64位中，整形数据只占用4字节空间，但编译器还是为其分配了8字节，不仅是为了方便系统对参数进行寻址，而且编译器会进行地址对齐，所以64位系统为所有数据类型大小小于8字节的类型，都保存8字节空间，同理，32位系统为所有数据类型都保存4字节空间。</p></li><li><p>win64 程序传递参数使用cd89这四个寄存器，超过四个参数的使用栈来传参，并且传递顺序是从右向左依次传参</p></li></ul></li></ol></li><li><p>GCC</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142925.png" srcset="/img/loading.gif" lazyload alt="image-20210106152821593"></p><p>*unix 64程序，优先使用 rdi，rsi，rdx，rcx，r8，r9，来传递前六个参数，然后利用栈来传递其余的参数。</p></li></ol><h2 id="chapter-7：全局、局部变量的使用"><a href="#chapter-7：全局、局部变量的使用" class="headerlink" title="chapter 7：全局、局部变量的使用"></a>chapter 7：全局、局部变量的使用</h2><h3 id="案例一：局部变量x"><a href="#案例一：局部变量x" class="headerlink" title="案例一：局部变量x"></a>案例一：局部变量x</h3><h5 id="x32"><a href="#x32" class="headerlink" title="x32"></a>x32</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142926.png" srcset="/img/loading.gif" lazyload alt="image-20210106154049714" style="zoom:67%"></li><li>x是局部变量，使用lea 得到 x的地址，</li><li>开头的push ecx，在结尾找不到对应的pop ecx，所以并不是保存ecx寄存器的作用，而是开辟了一个4字节的栈空间</li></ul><h6 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h6><ul><li>和msvc类似，只不过传参的时候使用mov 来传参</li></ul><h5 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h5><h6 id="msvc"><a href="#msvc" class="headerlink" title="msvc"></a>msvc</h6><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142927.png" srcset="/img/loading.gif" lazyload alt="image-20210106154443540" style="zoom:67%"><h6 id="gcc-1"><a href="#gcc-1" class="headerlink" title="gcc"></a>gcc</h6><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142928.png" srcset="/img/loading.gif" lazyload alt="image-20210106154533058" style="zoom:67%"> <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142929.png" srcset="/img/loading.gif" lazyload alt="image-20210106154539232" style="zoom:67%"><h3 id="案例二：全局变量x"><a href="#案例二：全局变量x" class="headerlink" title="案例二：全局变量x"></a>案例二：全局变量x</h3><ul><li>在linux x86中使用 全局变量是，变量x如果有不为0的初始值，那么编译器会将x存放在data段中，如果初始值为0，编译器会将x放在bss段中</li></ul><h3 id="案例三：对scanf-执行流程的控制"><a href="#案例三：对scanf-执行流程的控制" class="headerlink" title="案例三：对scanf 执行流程的控制"></a>案例三：对scanf 执行流程的控制</h3><h6 id="x32-1"><a href="#x32-1" class="headerlink" title="x32"></a>x32</h6><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142930.png" srcset="/img/loading.gif" lazyload alt="image-20210106155109552"></li><li>一般来说，条件判断语句会成对的出现 cmp/jcc 汇编指令，cmp会设置标志位，jcc会根据标志位来进行跳转</li></ul><h2 id="chapter-8：参数获取"><a href="#chapter-8：参数获取" class="headerlink" title="chapter 8：参数获取"></a>chapter 8：参数获取</h2><h3 id="x32-2"><a href="#x32-2" class="headerlink" title="x32"></a>x32</h3><h4 id="msvc-1"><a href="#msvc-1" class="headerlink" title="msvc"></a>msvc</h4><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142931.png" srcset="/img/loading.gif" lazyload alt="image-20210106161458950" style="zoom:50%"></li></ul><h4 id="gcc-2"><a href="#gcc-2" class="headerlink" title="gcc"></a>gcc</h4><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142932.png" srcset="/img/loading.gif" lazyload alt="image-20210106161520134" style="zoom:50%"></li><li>和msvc编译出来的程序大体一致，不过gcc没有使用 mov esp，ebp pop ebp来恢复栈帧，而是使用了leave 一条指令</li></ul><h3 id="x64-1"><a href="#x64-1" class="headerlink" title="x64"></a>x64</h3><h4 id="msvc-2"><a href="#msvc-2" class="headerlink" title="msvc"></a>msvc</h4><ul><li><p>开启优化</p><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142933.png" srcset="/img/loading.gif" lazyload alt="image-20210106161716202" style="zoom:67%"></li></ul></li><li><p>未开启优化</p><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142934.png" srcset="/img/loading.gif" lazyload alt="image-20210106161915956" style="zoom:67%"></li><li>原先位于寄存器中的三个参数先放入到了栈中，在从栈中取出数据进行运算，这个现象叫做 shadow space</li><li>在使用阴影空间时，由调用方函数分配栈空间，被调用函数使用栈空间</li></ul></li></ul><h2 id="chapter-9：返回值"><a href="#chapter-9：返回值" class="headerlink" title="chapter 9：返回值"></a>chapter 9：返回值</h2><p>在x86系统中，被调用方函数通常使用eax来返回运算结果，若返回值是char 或 byte 类型，返回值将存储在eax的低八位，al中，如果返回值是float 浮点数，那么返回值存储在 fpu 的 st(0)寄存器中。</p><h4 id="void型函数的返回值"><a href="#void型函数的返回值" class="headerlink" title="void型函数的返回值"></a>void型函数的返回值</h4><ul><li>在linux 中，如果main函数的类型是void，此时eax的值是最后一个被调用的函数返回的垃圾数据</li><li>在windows 中，msvc 2010，如果main返回void，编译器会将返回值设置为0</li></ul><h4 id="函数返回值不被调用的情况"><a href="#函数返回值不被调用的情况" class="headerlink" title="函数返回值不被调用的情况"></a>函数返回值不被调用的情况</h4><ul><li>返回的结果被抛弃</li></ul><h4 id="返回值为结构体类型的数据"><a href="#返回值为结构体类型的数据" class="headerlink" title="返回值为结构体类型的数据"></a>返回值为结构体类型的数据</h4><ul><li>如果函数的返回值是大型结构的数据，那么由调用方负责分配空间，给结构体分配指针，再将指针作为第一个参数传递给函数。</li></ul><h2 id="chpater-12：条件转移指令"><a href="#chpater-12：条件转移指令" class="headerlink" title="chpater 12：条件转移指令"></a>chpater 12：条件转移指令</h2><h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142935.png" srcset="/img/loading.gif" lazyload alt="image-20210106164244131" style="zoom:67%"><h5 id="x32-3"><a href="#x32-3" class="headerlink" title="x32"></a>x32</h5><ul><li><h6 id="msvc-3"><a href="#msvc-3" class="headerlink" title="msvc"></a>msvc</h6><ul><li><p>f_signed</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142936.png" srcset="/img/loading.gif" lazyload alt="image-20210106164820482" style="zoom:67%"></li><li><p>第一个条件转移指令是 jle，小于等于时跳转，如果大于，则不跳</p></li><li><p>第二个条件转移指令是 jnz，不等于时跳转，</p></li><li><p>第三个条件转移指令是 jge，大于等于时跳转，</p></li><li><p>这里检查的标志位是“sf xor of”（1 意味着异号） 和zf （1意味着相等）</p></li><li><p>f_unsigned<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142937.png" srcset="/img/loading.gif" lazyload alt="image-20210106165035187"></p></li><li><p>和f_signed 函数大体相同，只不过条件转移指令使用的是 jbe和 jnb（有可能使用jae）</p></li><li><p>这里跳转指令检查的是 cf （1意味着小于）和 zf（1意味着相等）</p></li></ul><h6 id="gcc-3"><a href="#gcc-3" class="headerlink" title="gcc"></a>gcc</h6><ul><li><p>gcc 在关闭优化的情况下，编译出来的程序与msvc编译出来的程序没什么区别</p><p>但是，在开启优化的情况下，gcc编译出来的指令如下，并且使用jmp替代了 call puts retn这种指令，</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142938.png" srcset="/img/loading.gif" lazyload alt="image-20210106165700489" style="zoom:67%"></li></ul></li></ul><h3 id="计算绝对值"><a href="#计算绝对值" class="headerlink" title="计算绝对值"></a>计算绝对值</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142939.png" srcset="/img/loading.gif" lazyload alt="image-20210106170021054"></p><h5 id="msvc-x64"><a href="#msvc-x64" class="headerlink" title="msvc x64"></a>msvc x64</h5><ul><li><p>debug</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142940.png" srcset="/img/loading.gif" lazyload alt="image-20210106170349538" style="zoom:67%"></li><li><p>release</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142941.png" srcset="/img/loading.gif" lazyload alt="image-20210106170441168" style="zoom:67%"></li><li><p>debug下，msvc编译的结果比较繁琐，realease进行了一定的优化</p></li></ul><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142942.png" srcset="/img/loading.gif" lazyload alt="image-20210106184559226" style="zoom:67%"><h5 id="x32-4"><a href="#x32-4" class="headerlink" title="x32"></a>x32</h5><ul><li>早期无优化的编译器将条件运算编译成if/else，代码较复杂，</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142943.png" srcset="/img/loading.gif" lazyload alt="image-20210106190118699" style="zoom:67%"> <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142944.png" srcset="/img/loading.gif" lazyload alt="image-20210106190132445" style="zoom:67%"><ul><li>新编译器生成的代较简洁</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142945.png" srcset="/img/loading.gif" lazyload alt="image-20210106190159976" style="zoom:67%"><h5 id="x64-2"><a href="#x64-2" class="headerlink" title="x64"></a>x64</h5><p>msvc</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142946.png" srcset="/img/loading.gif" lazyload alt="image-20210106190234194" style="zoom:67%"><ul><li>使用cmove指令，根据zf标志位决定是否将rdx赋值给rax</li></ul><h3 id="比较最大值和最小值"><a href="#比较最大值和最小值" class="headerlink" title="比较最大值和最小值"></a>比较最大值和最小值</h3><h5 id="x32-5"><a href="#x32-5" class="headerlink" title="x32"></a>x32</h5><ul><li>不启用优化，使用条件转移指令，启用优化，使用cmovcc 指令</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142947.png" srcset="/img/loading.gif" lazyload alt="image-20210106190847448" style="zoom:67%"> <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142948.png" srcset="/img/loading.gif" lazyload alt="image-20210106190855157" style="zoom:67%"><h5 id="x64-3"><a href="#x64-3" class="headerlink" title="x64"></a>x64</h5><ul><li>和x32类似</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>条件转移指令构造大体如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">cmp reg1, reg2&#x2F;value<br>jcc true<br>false:<br>	some code to be excuted if comparsion is false<br>	jmp exit<br>true:<br>	some code to be excuted if comparsion is true<br>exit:<br></code></pre></div></td></tr></table></figure><ul><li>无分支指令</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">cmovcc<br></code></pre></div></td></tr></table></figure><h2 id="chapter-13：switch-case-default"><a href="#chapter-13：switch-case-default" class="headerlink" title="chapter 13：switch/case/default"></a>chapter 13：switch/case/default</h2><h3 id="13-1-case-较少的情况"><a href="#13-1-case-较少的情况" class="headerlink" title="13.1 case 较少的情况"></a>13.1 case 较少的情况</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142949.png" srcset="/img/loading.gif" lazyload alt="image-20210106191409649"></p><h5 id="x32-6"><a href="#x32-6" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化，msvc 2010</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142950.png" srcset="/img/loading.gif" lazyload alt="image-20210106191447004" style="zoom:67%"> <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142951.png" srcset="/img/loading.gif" lazyload alt="image-20210106191456021" style="zoom:67%"><ul><li>开启优化 msvc<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142952.png" srcset="/img/loading.gif" lazyload alt="image-20210106191940000"><ul><li>将字符串直接赋值给变量后，直接jmp指令调用printf 函数，省略了一次call指令造成的函数返回开销</li></ul></li></ul><h3 id="13-2-case-较多的情况"><a href="#13-2-case-较多的情况" class="headerlink" title="13.2 case 较多的情况"></a>13.2 case 较多的情况</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142953.png" srcset="/img/loading.gif" lazyload alt="image-20210106192216873" style="zoom:67%"><h5 id="x32-7"><a href="#x32-7" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142954.png" srcset="/img/loading.gif" lazyload alt="image-20210106192430727" style="zoom:67%"></li><li>case值连续较多的情况下，会生成一张jmp表，用case的值作为索引</li></ul></li><li>无优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142955.png" srcset="/img/loading.gif" lazyload alt="image-20210106192554211" style="zoom:67%"></li><li>和 msvc 类似，都使用了jmp 表</li></ul></li><li>总结<ul><li>switch中case较多的情况，通常会采取jmp表</li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142956.png" srcset="/img/loading.gif" lazyload alt="image-20210106192722581" style="zoom:67%"></li></ul></li></ul><h3 id="13-3-case-多对一的情况"><a href="#13-3-case-多对一的情况" class="headerlink" title="13.3 case 多对一的情况"></a>13.3 case 多对一的情况</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142957.png" srcset="/img/loading.gif" lazyload alt="image-20210106192744570" style="zoom:67%"><h5 id="msvc-4"><a href="#msvc-4" class="headerlink" title="msvc"></a>msvc</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142958.png" srcset="/img/loading.gif" lazyload alt="image-20210106192845348" style="zoom:67%"></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142959.png" srcset="/img/loading.gif" lazyload alt="image-20210106192859484" style="zoom:67%"></li><li>程序中用到两张表，一张索引表，一张转移表</li><li>程序先根据输入值从索引表中取出索引，再根据索引去转移表中寻找转移的地址</li></ul><h2 id="chapter-14：循环"><a href="#chapter-14：循环" class="headerlink" title="chapter 14：循环"></a>chapter 14：循环</h2><h3 id="14-1-for循环"><a href="#14-1-for循环" class="headerlink" title="14.1 for循环"></a>14.1 for循环</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143000.png" srcset="/img/loading.gif" lazyload alt="image-20210106193322036" style="zoom:67%"><ul><li>msvc 2010 未开启优化<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143001.png" srcset="/img/loading.gif" lazyload alt="image-20210106193345908" style="zoom:67%"></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143002.png" srcset="/img/loading.gif" lazyload alt="image-20210106193353187" style="zoom:67%"></li></ul></li><li>msvc 2010 开启优化<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143003.png" srcset="/img/loading.gif" lazyload alt="image-20210106193505419" style="zoom:67%"></li><li>开启优化后，编译器将局部变量i优化成使用寄存器esi，在局部变量为数不多的情况下，编译器通常会进行这种优化。</li></ul></li><li>总结：<ul><li>循环编译出来的代码一般开始会有一个条件判断，判断循环的条件是否成立，成立之后再执行循环体，循环体执行完后，会跳转到（可能有）对循环变量更改的地方，更改完后会再次判断循环条件是否成立。</li><li>如果编译器能够检测循环语句的初始状态不可能满足循环体的执行条件，那么编译器可能根本不会为循环条件和循环体生成对应的指令</li></ul></li></ul><h3 id="14-2-内存块复制"><a href="#14-2-内存块复制" class="headerlink" title="14.2 内存块复制"></a>14.2 内存块复制</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143004.png" srcset="/img/loading.gif" lazyload alt="image-20210106194114650"></p><ul><li>gcc x64<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143005.png" srcset="/img/loading.gif" lazyload alt="image-20210106194140535" style="zoom:67%"></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143006.png" srcset="/img/loading.gif" lazyload alt="image-20210106194145720" style="zoom:67%"></li></ul></li></ul><h3 id="14-3-总结"><a href="#14-3-总结" class="headerlink" title="14.3 总结"></a>14.3 总结</h3><ul><li>一般的循环指令格式如下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">	mov [counter], 2<br>	jmp check<br>body:<br>	;loop body<br>	;do something here<br>	;user counter value in local stack<br>	add [counter], 1<br>check:<br>	cmp [counter], 9<br>	jle body<br></code></pre></div></td></tr></table></figure><ul><li>如果没有开启优化选项，那么控制变量递增的语句(add [counter], 1)可能递增为三条指令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">	mov [counter], 2<br>	jmp check<br>body:<br>	;loop body<br>	;do something here<br>	; use counter in ebx<br>	mov reg, [counter]<br>	inc reg<br>	mov [couner], reg<br>check:<br>	cmp [counter], 9<br>	jle body<br></code></pre></div></td></tr></table></figure><ul><li>当循环体比较短小，或局部变量较少时，编译器可能会给循环条件分配专用的寄存器</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">	mov ebx, 2<br>	jmp check<br>body:<br>	;loop body<br>	;do something here<br>	inc ebx<br>check:<br>	cmp ebx, 9<br>	jle body<br><br></code></pre></div></td></tr></table></figure><ul><li>编译器还可能调换部分指令的顺序</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">	mov [counter], 2<br>	jmp label_check<br>label_increment:<br>	add [counter], 1<br>lable_check:<br>	cmp [counter], 10<br>	jge exit<br>	;loop body<br>	;do something here<br>	jmp label_increment<br>exit:<br></code></pre></div></td></tr></table></figure><ul><li>通常情况下，程序执行应当首先判断执行条件是否满足，然后再执行循环体，但当编译器能确定第一次迭代肯定会发生的 情况下，它可能会调换循环体语句和判断语句的位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">	mov reg, 2<br>body:<br>	;loop body<br>	;do something here<br>	inc reg<br>	cmp reg<br>	jl body<br></code></pre></div></td></tr></table></figure><ul><li>为什么现在编译器都不使用loop语句了？</li></ul><p>循环体语句过于复杂，而loop只会检测ecx寄存器的值是否为0，不为0则递减然后跳转到循环体</p><h2 id="chapter-15：strlen"><a href="#chapter-15：strlen" class="headerlink" title="chapter 15：strlen"></a>chapter 15：strlen</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143007.png" srcset="/img/loading.gif" lazyload alt="image-20210108162715646"></li></ul><h5 id="x32-8"><a href="#x32-8" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143008.png" srcset="/img/loading.gif" lazyload alt="image-20210108162754990" style="zoom:67%"></li></ul></li><li>无优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143009.png" srcset="/img/loading.gif" lazyload alt="image-20210108162825818" style="zoom:67%"></li><li>setnz al，当zf 为0时，设置al为1</li></ul></li><li>开启优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143010.png" srcset="/img/loading.gif" lazyload alt="image-20210108162908071" style="zoom:67%"></li></ul></li><li>开启优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143011.png" srcset="/img/loading.gif" lazyload alt="image-20210108162946018" style="zoom:67%"></li></ul></li></ul><h5 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143012.png" srcset="/img/loading.gif" lazyload alt="image-20210108163031836" style="zoom:67%"><ul><li><p>```c<br>int count_32(const char * str)<br>{</p><div class="hljs code-wrapper"><pre><code>int count = 0;
if(*str)&#123;
    while(*str)&#123;
        if (*str++ == 32)
            count++;
    &#125;
&#125;
return count;
</code></pre></div><p>}</p><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml"><br>-<span class="ruby"> &lt;img src=<span class="hljs-string">&quot;https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143013.png&quot;</span> alt=<span class="hljs-string">&quot;image-20210108163301665&quot;</span> style=<span class="hljs-string">&quot;zoom:67%;&quot;</span> /&gt;</span><br><br><span class="ruby">  - 和上面功能一样</span><br><br><span class="ruby"><span class="hljs-comment">## chapter 16：数学计算指令的替换</span></span><br><br><span class="ruby"><span class="hljs-comment">### 16.1 乘法</span></span><br><br><span class="ruby">- 替换为加法运算</span><br><br><span class="ruby">  - ![image-<span class="hljs-number">20210108163557037</span>](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/gitee.com/zaixiabeiming</span><span class="hljs-regexp">/blog_image/raw</span><span class="hljs-regexp">/master/images</span><span class="hljs-regexp">/20210320143014.png)</span></span><br><br><span class="ruby">- 替换为位移运算</span><br><br><span class="ruby">  - ![image-<span class="hljs-number">20210108163613817</span>](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/gitee.com/zaixiabeiming</span><span class="hljs-regexp">/blog_image/raw</span><span class="hljs-regexp">/master/images</span><span class="hljs-regexp">/20210320143015.png)</span></span><br><br><span class="ruby">- 替换为位移、加法的混合运算</span><br><br><span class="ruby">  - x32</span><br><br><span class="ruby">    - &lt;img src=<span class="hljs-string">&quot;https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143016.png&quot;</span> alt=<span class="hljs-string">&quot;image-20210108163655176&quot;</span> style=<span class="hljs-string">&quot;zoom:67%;&quot;</span> /&gt;</span><br><br><span class="ruby">    - <span class="hljs-string">``</span><span class="hljs-string">`asm</span></span><br><span class="ruby">      ; <span class="hljs-keyword">return</span> a * <span class="hljs-number">7</span></span><br><span class="ruby">      ; ecx = a</span><br><span class="ruby">      mov ecx, dword ptr <span class="hljs-symbol">ds:</span>[esp+<span class="hljs-number">4</span>]</span><br><span class="ruby">      ; eax = ecx * <span class="hljs-number">8</span></span><br><span class="ruby">      lea eax, dword ptr [ecx*<span class="hljs-number">8</span>]</span><br><span class="ruby">      ; eax = eax - ecx = ecx * <span class="hljs-number">8</span> - ecx = ecx * <span class="hljs-number">7</span></span><br><span class="ruby">      sub eax, ecx</span><br></code></pre></div></td></tr></table></figure><ul><li>```asm<br>; return a * 28<br>mov ecx, dword ptr ds:[esp + 4]<br>lea eax, dword ptr [ecx * 8]<br>sub eax, ecx<br>shl eax, 2<figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><br>- <span class="hljs-string">```</span>asm<br>  <span class="hljs-comment">; return a * 17</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">esp</span> + <span class="hljs-number">4</span>]<br>  <span class="hljs-keyword">shl</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">4</span><br>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">esp</span> + <span class="hljs-number">4</span>]<br>  <span class="hljs-keyword">ret</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="16-2-除法运算"><a href="#16-2-除法运算" class="headerlink" title="16.2 除法运算"></a>16.2 除法运算</h3><ul><li><p>替换为位移运算</p><ul><li><div class="hljs code-wrapper"><pre><code class="asm">; return unsinged int a / 4
mov eax, dword ptr ds:[esp + 4]
shr eax, 2
ret
</code></pre></div></li></ul></li></ul><h3 id="16-3-练习题"><a href="#16-3-练习题" class="headerlink" title="16.3 练习题"></a>16.3 练习题</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143017.png" srcset="/img/loading.gif" lazyload alt="image-20210108164448768"><ul><li>返回 参数 * 7</li></ul></li></ul><h2 id="chapter-17：FPU"><a href="#chapter-17：FPU" class="headerlink" title="chapter 17：FPU"></a>chapter 17：FPU</h2><h3 id="17-1-浮点数-intel-存储方式"><a href="#17-1-浮点数-intel-存储方式" class="headerlink" title="17.1 浮点数 intel 存储方式"></a>17.1 浮点数 intel 存储方式</h3><p>在x86上，80486处理器问世之前，fpu叫做协、辅助处理器，80486之后，cpu集成了fpu的功能。</p><p>在80486之前，提供的fwait指令，和opcode以d8-df开头的指令，fwait的作用是让cpu等待fpu运算完毕。</p><p>fpu自带一个8个80位寄存器构成的循环栈。这些80位寄存器以ieee 754 格式存储浮点数数据，通常叫做ST(0)-ST(7)寄存器。</p><p>ida和od都把 st(0) 显示为st。不少书籍也将 st(0) 叫做栈顶寄存器</p><h3 id="17-2-浮点数运算"><a href="#17-2-浮点数运算" class="headerlink" title="17.2 浮点数运算"></a>17.2 浮点数运算</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143018.png" srcset="/img/loading.gif" lazyload alt="image-20210108165211144"></li><li>x32 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143019.png" srcset="/img/loading.gif" lazyload alt="image-20210108165338437" style="zoom:67%"></li><li>指令1执行后：st0寄存器是参数一<ul><li>fld从栈中读取八个字节，并将这个值转换为fpu寄存器的80位格式</li></ul></li><li>指令2执行后：st0寄存器是参数一除以3.14的结果<ul><li>fdiv指令将st0寄存器的值作为被除数，运算之后，st0将保存商</li><li>fdivp指令在运算时，先将st1 st0的值pop之后，运算之后，将结果再push，此时st0将保存商</li></ul></li><li>指令3执行后：st0寄存器是参数二，st1是参数一除以3.14的结果</li><li>指令4执行后：st0寄存器是参数二乘以4.1的结果<ul><li>fmul指令将st0寄存器中的值乘以后面的参数，并将结果保存到st0寄存器中</li></ul></li><li>指令5执行后：st0寄存器就是计算的结果<ul><li>faddp st1，st0 指令计算栈顶两个值的和，先把运算结果存储在st1寄存器，再pop st1。所以运算表达式的结果存储在栈顶的st0寄存器里。</li></ul></li><li>如果一个函数的返回值是一个浮点数，那么返回值约定放在寄存器st0中</li></ul></li><li>x32 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143020.png" srcset="/img/loading.gif" lazyload alt="image-20210108183828473" style="zoom:67%"></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143021.png" srcset="/img/loading.gif" lazyload alt="image-20210108183834352" style="zoom:67%"></li><li>fld 将3.14 加载到寄存器 st0 中</li><li>fdivr 是reverse divide 的缩写，操作数和fdiv 相反，所以此时将 ebp+arg0 作为被除数，将 st0 作为除数</li><li>faddp 将st1 和 st0的值pop出来，计算出的结果再放回st0中</li></ul></li></ul><h3 id="17-3-传递浮点参数"><a href="#17-3-传递浮点参数" class="headerlink" title="17.3 传递浮点参数"></a>17.3 传递浮点参数</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143022.png" srcset="/img/loading.gif" lazyload alt="image-20210108184227496"></li><li>开辟了两个全局变量来存储参数，传参时先将值加载到寄存器中，然后再写入栈中。（因为汇编指令的操作数不能是立即数？maybe。。。）</li></ul></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E9%80%86%E5%90%91/">逆向</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/windows/">windows</a> <a class="hover-with-bg" href="/tags/%E9%80%86%E5%90%91/">逆向</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p><div class="post-prevnext"><article class="post-prev col-6"><a href="/2021/03/25/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90irq%E4%B8%8Eirql%EF%BC%9A%E4%BB%8Epic%E5%88%B0apic/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">深入解析irq与irql：从pic到apic</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2021/03/19/DEP%20%E5%8E%9F%E7%90%86%E5%8F%8APass/"><span class="hidden-mobile">DEP原理及ByPass</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></div></div></div><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer class="text-center mt-5 py-3"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/killaragorn/" target="_blank" rel="nofollow noopener"><span>KillAragorn</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></footer><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script><script>!function(t,i){(0,Fluid.plugins.typing)(i.getElementById("subtitle").title)}(window,document)</script><script src="/js/local-search.js"></script><script>$("#local-search-input").on("click",(function(){searchFunc("/local-search.xml","local-search-input","local-search-result")})),$("#modalSearch").on("shown.bs.modal",(function(){$("#local-search-input").focus()}))</script><script defer>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?ac869ccd147869a461a862e3e2b3e282";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script src="/js/boot.js"></script></body></html>