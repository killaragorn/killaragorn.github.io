<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>wow64系统函数执行流程分析</title>
    <link href="/2021/04/10/wow64%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <url>/2021/04/10/wow64%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<ol><li> 本文以win764 sp1 为例子，研究 32程序是如何在64位系统上运行的。</li></ol><ul><li>  使用 windbg 64位启动目标程序，查看程序加载的模块，发现程序加载了两个ntdll，其中ntdll32是作为32程序调用64程序的入口点</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104748.png" alt="image-20210410091209936"></p><ul><li>  从 kernel32！CreateFileW开始发现 CreateFileW进入kernelBase的CreateFileW（这是pe的导入表转发）</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104749.png" alt="image-20210410092700216"></p><ul><li>  KernelBase中CreateFileW做了很多参数的判断和转化，复杂了一些，我们找到 调用 ntdll32！NtCreateFile的地方</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104750.png" alt="image-20210410092937245"></p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104751.png" alt="image-20210410093025944"></p><ul><li>  在 ntdll32！NtCreateFile中，将eax赋值为函数调用编号，edx指向栈上的参数，将ecx清零，然后经过一个call跳走，我们来看看 fs:[c0]中是个什么。在64位系统中，fs指向当前线程的TEB，32位程序中，fs指向的 32位的TEB，GS指向的是64位的TEB，查看TEB32的结构体，发现这个字段是WOW32Reserved，在window 32位系统中，windows支持16位程序的运行就是通过这个字段进行中转，所有64系统中还是使用这个字段进行中转。</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104752.png" alt="image-20210410093736445"></p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104753.png" alt="image-20210410093358821"></p><ul><li>  反汇编这个地址之后发现，这地址属于模块 wow64cpu，同时这个模块属于<code>c:\windows\system32</code>目录，是一个64位的模块 ，我们现在来整理一下调用逻辑<code>kernle32!CreateFileW -&gt; kernelBase!CreateFileW  -&gt; ntdll32!NtCreateFile  -&gt; wow64cpu!x86SwitchTo64BitMode</code>，根据这个符号的名字，我们确定这是32位进入64的入口点，那么到底是如何转换的呢？就是通过下面这条长跳指令<code>jmp 0033:74eb271e</code>转换的。这里经历了一个长跳，段寄存器由23变为33，挂上双机调试，查看一下段选择子的属性，发现33这个段选择子指向的代码段已经是64位的了。</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104754.png" alt="image-20210410094407223"></p><ul><li>  单步一下，发现跳转的目标是<code>wow64cpu!CpupReturnFromSimulatedCode</code>，来看一下这些代码究竟做了些什么事。</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104755.png" alt="image-20210410094530570"></p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104756.png" alt="image-20210410094915533"></p><ul><li>  ①：将之前 <code>call dword ptr fs:[c0]</code>取出32位的返回地址</li><li>  ②：将返回地址保存起来</li><li>  ③：保存32位的esp</li><li>  ④：r12 这里指向的是TEB， R12+1480H 是 TLS Slots，存储了一些64位线程的环境以及32位线程的数据。</li><li>  ⑤：对 Tls slots 中缓存的 rsp 清零</li><li>  ⑥：edx 中存储的是参数的起始地址，现在保存到r11d中</li><li>  ⑦：这里起始是一个优化后的 switch case 结构的查找表，使用 <code>dps r15</code>  查看一下这个表中存储了哪些数据。这个表中存储的各个函数地址其实针对的是调用时32位传进来的参数是否需要参数转换，大部分的nt函数的ecx都是0，所以接下来主要分析 ecx = 0的情况。</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104757.png" alt="image-20210410095643648"></p><ul><li>  ecx = 0时，以下这些代码，将一些寄存器的值保存起来之后，将eax存储的内核调用号给了ecx，然后调用<code>wow64cpu!_imp_Wow64SystemServiceEx </code>函数</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104758.png" alt="image-20210410100245416"></p><ul><li>  接下来主要分析wow64cpu!_imp_Wow64SystemServiceEx 这个函数，这个函数还是稍微复杂一点</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104759.png" alt="image-20210410103245446"></p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104800.png" alt="image-20210410103307091"></p><ul><li>  在 call r12 下断，调用进入 <code>wow64!whNtCreateFile</code>函数，这个函数中，将参数转换成64位，然后就直接执行64位的 NtCreateFile 函数了。</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210410104801.png" alt="image-20210410103653508"></p><ul><li>总结一下：在window 64上的 32 程序调用系统 API时，流程如下<ol><li> <code>kernel32!CreateFileW</code></li><li> <code>kernelBase!CreateFileW</code></li><li> <code>ntdll32!NtCreateFile</code></li><li> <code>wow64cpu!x86SwitchTo64BitMode</code></li><li> <code>wow64cpu!CpupReturnFromSimulatedCode</code>：这里会根据系统调用跳转到不同的地方，我们值分析了 ecx为0的情况。</li><li> ecx = 0 时，<code>wow64cpu!_imp_Wow64SystemServiceEx </code>：根据系统调用号的高4位作为函数表索引，低12位作为函数表内地址索引。跳转到对应的wow64转换函数中</li><li> <code>wow64!whNtCreateFile</code>：这里对参数进行了转换，然后调用64位的nt函数</li><li> <code>ntdll!NtCreateFile</code></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向</tag>
      
      <tag>wow64</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>沙箱实现原理</title>
    <link href="/2021/04/09/%E6%B2%99%E7%AE%B1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/09/%E6%B2%99%E7%AE%B1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>// 初次记录，待整理。。</p><ul><li><p>注册表回调</p><ul><li>  原理与minifilter一样</li></ul></li><li><p>sandbox中几个重要的概念</p><ul><li>  路径，删除，重定向，in and out sandbox</li><li>  文件，注册表，rpc lpc 通讯</li></ul></li><li><p>  沙盒根目录：\device\harddiskvolume1\sandbox</p></li><li><p>源路径：\device\harddiskvolume2\doc\hi.txt</p><ul><li>  内部路径：\device\harddiskvolume1\sandbox\harddiskvolume2\doc\hi.txt</li><li>  删除标记：\device\harddiskvolume1\sandbox\harddiskvolume2\doc\hi.txt.del</li></ul></li><li><p>操作文件：</p><ul><li>  外部已存在：拷贝外部到内部（层层复制），拷贝时，文件属性权限，ads流也要拷贝。之后再以新的路径重新发送irp</li><li>  外部不存在：内部直接创建文件。</li></ul></li><li><p>删除文件：</p><ul><li>外部已存在：标记为删除，但不要删除（遍历时要过滤此项）<ul><li>  沙盒程序遍历文件时：求一个外部路径与内部路径的交集，然后去除标记为删除的项</li></ul></li><li>  外部不存在：可以直接删除</li></ul></li><li><p>文件重定向实现</p><ul><li><p>windows io 管理器提供了一个方便的方法来重定向一个文件对象。通常使用文件过滤驱动（在文件打开和文件创建操作中）实现该方法，步骤如下</p><ol><li> 在 IRP_MJ_CREATE 的分发函数中，获得FILE_OBJECT的FileName 属性</li><li>用目标文件的完整路径替换源头的文件名字<ol><li> 用全名，包括卷设备对象的名字（例：Device\HardDiskVolume0\Doc\1.txt）</li><li> 可以释放掉原有的FileName.Buffer，同时用自己定义的缓冲区（buffer以nonpagedpool方式申请）替换它</li></ol></li><li> 设置 IoStatus的status字段为 STATUS_REPARSE，然后设置infomation字段为IO_REPARSE</li><li> 完成该irp请求</li><li> 返回 STATUS_REPARSE</li><li> minifilter中要调用 FltSetCallbackDataDirty（data）</li><li> io管理器接收到该返回后，便会触发另外一个文件打开操作，并发送一个IRP_MJ_CREATE的申请。</li></ol></li><li><p>具体实现</p><ul><li><p>CreateFile</p><ul><li>  首先确定该进程是否需要沙盒</li><li>  获取文件名（外部和内部的文件名）</li><li>判断沙盒中是否含有该文件的del文件，如果有则按照是否来自insandbox的请求和是否改变文件进行处理。<ul><li>  创建或改变该文件，来自外面，则重定向到内部</li><li>  创建或改变该文件，来自里面，则删除该标志文件，并交给文件系统去创建</li><li>  只读操作该文件，含有删除标志，访问失败</li></ul></li><li>  如果sandbox里面存在该文件，切请求来自sandbox，交给文件系统去处理；请求来自外面，reparse到里面</li><li>  如果操作不改变文件，但sandbox里没有这个文件并且请求来自sandbox，则reparse到外面；否则交给文件系统处理</li><li>操作改变文件，sandbox里没有该文件，则准备路径；如果sandbox外面有该文件，则负责<strong>拷贝</strong><ul><li>  拷贝时注意属性，流</li></ul></li><li>  重定向reparse</li></ul></li></ul></li></ul></li><li><p>DeleteFile</p><pre><code>      -   IRP_MJ_SET_INFORMATION          -   FileDispostionInformation      -   思路          -   获得文件名（外部和内部的文件名）          -   判断是否来自sandbox里面还是外面          -   如果是外面路径，则转换里面路径              -   不删除外面文件，在里面设置一个删除标志          -   如果是里面路径，获得外面路径              -   如果外面不存在，直接删除里面该文件              -   如果外面存在，则在里面建立一个删除标志，并删除  -   QueryDir      -   IRP_MJ_DIRECTORY_CONTROL      -   首先确定该进程是否需要sandbox      -   获取文件名（里面和外面的路径）      -   查询里面文件，并去掉含删除标记的文件      -   查询外部文件，并去掉含删除标记的文件      -   合并两部分内容  -   WriteFile      -   不需要重定向</code></pre></li><li><p>判断如何在沙盒内</p><ul><li>  windows最大路径260，so you know。。。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows驱动开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows驱动开发</tag>
      
      <tag>沙箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MiniFilter 文件过滤框架复习</title>
    <link href="/2021/04/07/MiniFilter-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/"/>
    <url>/2021/04/07/MiniFilter-%E6%96%87%E4%BB%B6%E8%BF%87%E6%BB%A4%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="Minifile-与-Sfilter-的区别"><a href="#Minifile-与-Sfilter-的区别" class="headerlink" title="Minifile 与 Sfilter 的区别"></a>Minifile 与 Sfilter 的区别</h3><ul><li>minifilter 比 sfilter 加载顺序更易控制（sfilter处于设备栈中的顺序由过滤驱动加载顺序不同而不同），altitude由filter管理器根据这个altitude值(值越大越上层)调用驱动回调，被绑定到合适的位置。<ul><li>  由于minifilter的altitude值决定过滤驱动在filter的管理器中处理数据的先后，反病毒驱动一般在高处，透明管加解密一般在低处。</li><li>  微软也将altitude分配了几个组</li></ul></li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210407204438.png" alt="image-20210407202622438"></p><ul><li>  安全卸载能力：向filter管理器取消注册</li><li>  callback模型仅需处理必要的操作的能力</li><li>  兼容性更好</li><li>  名字处理更容易</li><li>  安装方式（.inf、动态加载（比传统的nt驱动需要多创建几个键））</li><li>  专用的通信方式</li><li>  同样要遵循内核驱动编码规则，irql，锁等内核开发通用机制</li><li>  当系统中同时存在minifilter和legacy filter时</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210415105116.png" alt="总体框架"></p><h3 id="minifilter-过滤框架"><a href="#minifilter-过滤框架" class="headerlink" title="minifilter 过滤框架"></a>minifilter 过滤框架</h3><ul><li><p>驱动入口：初始化 FLT_REGISTRATION 结构体 ，向过滤管理器注册和启动：FltRegisterFilter，FltStartFiltering</p><p>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210415105117.png" alt="minifilter结构"></p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><code class="hljs c">PFLT_FILTER g_pFilter = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">const</span> FLT_CONTEXT_REGISTRATION <br>ContextRegistration[] = <br>&#123;<span class="hljs-comment">//在释放context之前调用，可以在此释放context里的内存等</span><br>&#123; <br>FLT_INSTANCE_CONTEXT,<br><span class="hljs-number">0</span>,<br>CtxContextCleanup,<br>CTX_INSTANCE_CONTEXT_SIZE,<br>CTX_INSTANCE_CONTEXT_TAG <br>&#125;,<br>&#123; <br>FLT_FILE_CONTEXT,<br><span class="hljs-number">0</span>,<br>CtxContextCleanup,<br>CTX_FILE_CONTEXT_SIZE,<br>CTX_FILE_CONTEXT_TAG <br>&#125;,<br>&#123; <br>FLT_STREAM_CONTEXT,<br><span class="hljs-number">0</span>,<br>CtxContextCleanup,<br>CTX_STREAM_CONTEXT_SIZE,<br>CTX_STREAM_CONTEXT_TAG<br> &#125;,<br>&#123;<br>FLT_STREAMHANDLE_CONTEXT,<br><span class="hljs-number">0</span>,<br>CtxContextCleanup,<br>CTX_STREAMHANDLE_CONTEXT_SIZE,<br>CTX_STREAMHANDLE_CONTEXT_TAG<br> &#125;,<br>&#123; FLT_CONTEXT_END &#125;<br>&#125;;<br><br><br>CONST FLT_REGISTRATION FilterRegistration = &#123;<br><br>    <span class="hljs-keyword">sizeof</span>( FLT_REGISTRATION ),         <span class="hljs-comment">//  Size</span><br>    FLT_REGISTRATION_VERSION,           <span class="hljs-comment">//  Version</span><br>    <span class="hljs-number">0</span>,                                  <span class="hljs-comment">//  Flags</span><br><br>    ContextRegistration,                               <span class="hljs-comment">//  Context</span><br>    Callbacks,                          <span class="hljs-comment">//  Operation callbacks</span><br><br>    PtUnload,                           <span class="hljs-comment">//  MiniFilterUnload</span><br><br>    PtInstanceSetup,                    <span class="hljs-comment">//  InstanceSetup</span><br>    PtInstanceQueryTeardown,            <span class="hljs-comment">//  InstanceQueryTeardown</span><br>    PtInstanceTeardownStart,            <span class="hljs-comment">//  InstanceTeardownStart</span><br>    PtInstanceTeardownComplete,         <span class="hljs-comment">//  InstanceTeardownComplete</span><br><br>    <span class="hljs-literal">NULL</span>,                               <span class="hljs-comment">//  GenerateFileName</span><br>    <span class="hljs-literal">NULL</span>,                               <span class="hljs-comment">//  GenerateDestinationFileName</span><br>    <span class="hljs-literal">NULL</span>                                <span class="hljs-comment">//  NormalizeNameComponent</span><br><br>&#125;;<br><br>CONST FLT_OPERATION_REGISTRATION Callbacks[] = &#123;<br>    &#123; IRP_MJ_CREATE,<br>      <span class="hljs-number">0</span>,<br>      PtCreatePreOperationPassThrough,<br>      PtCreatePostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_CREATE_NAMED_PIPE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_CLOSE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_READ,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_WRITE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_QUERY_INFORMATION,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_SET_INFORMATION,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_QUERY_EA,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_SET_EA,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_FLUSH_BUFFERS,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_QUERY_VOLUME_INFORMATION,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_SET_VOLUME_INFORMATION,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_DIRECTORY_CONTROL,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_FILE_SYSTEM_CONTROL,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_DEVICE_CONTROL,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_INTERNAL_DEVICE_CONTROL,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_SHUTDOWN,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationNoPostOperationPassThrough,<br>      <span class="hljs-literal">NULL</span> &#125;,                               <span class="hljs-comment">//post operations not supported</span><br><br>    &#123; IRP_MJ_LOCK_CONTROL,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_CLEANUP,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_CREATE_MAILSLOT,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_QUERY_SECURITY,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_SET_SECURITY,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_QUERY_QUOTA,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_SET_QUOTA,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_PNP,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_RELEASE_FOR_SECTION_SYNCHRONIZATION,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_ACQUIRE_FOR_MOD_WRITE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_RELEASE_FOR_MOD_WRITE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_ACQUIRE_FOR_CC_FLUSH,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_RELEASE_FOR_CC_FLUSH,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_FAST_IO_CHECK_IF_POSSIBLE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_NETWORK_QUERY_OPEN,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_MDL_READ,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_MDL_READ_COMPLETE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_PREPARE_MDL_WRITE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_MDL_WRITE_COMPLETE,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_VOLUME_MOUNT,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_VOLUME_DISMOUNT,<br>      <span class="hljs-number">0</span>,<br>      PtPreOperationPassThrough,<br>      PtPostOperationPassThrough &#125;,<br><br>    &#123; IRP_MJ_OPERATION_END &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>  驱动卸载：调用 FltUnregisterFilter卸载回调</p></li><li><p>过滤函数</p><ul><li>PreNtCreateFile：返回值类型 FLT_PPREOP_CALLBACK_STATUS<ul><li>几种返回值类型<ul><li>  <strong>FLT_PREROP_SUCCESS_WITH_CALLBACK</strong>：向下传递，完成irp后会调用post</li><li>  <strong>FLT_PREOP_SUCCESS_NO_CALLBACK</strong>：向下传递，完成irp后不会调用post</li><li>  FLT_PREOP_PENDING</li><li>  FLT_PREOP_DISALLOC_FASTIO</li><li>  <strong>FLT_PREOP_COMPLETE</strong>：直接完成irp，不向下传递</li><li>  FLT_PREOP_SYNCHRONIZE</li></ul></li></ul></li><li>PostNtCreateFile：在irp完成之后，在这里拿到文件名等其他信息。<ul><li>几种返回值类型<ul><li>  <strong>FLT_POSTOP_FINISHED_PROCESSING</strong>：</li><li>  FLT_POSTOP_MORE_PROCESSING_REQUIRED</li></ul></li></ul></li><li>判断Data是什么操作的宏<ul><li>  FLT_IS_IRP_OPERATION</li><li>  FLT_IS_FASTIO_OPERATION</li><li>  FLT_IS_FS_FILTER_OPERATION</li></ul></li></ul></li><li><p>监控进程创建</p><ul><li>  进程创建因为是映射内存区，底层函数是NtCreateSection</li><li>  IRP 是：IRP_MJ_ACQUIRE_FOR_SECITON_SYNCHRONIZATION，切data-&gt;iopb-&gt;Parameters.AcquireForSectionsSynchronization.PageProtection == Page_execute</li></ul></li><li><p>  过滤函数中获取参数</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 过滤函数的参数中有 Data</span><br>PFLT_CALLBACK_DATA Data；<br><span class="hljs-comment">// 获取进程对象</span><br>PEPROCESS processObject = <br>Data-&gt;Thread ? IoThreadToProcess(Data-&gt;Thread) : PsGetCurrentProcess();<br><span class="hljs-comment">// 获取当前进程PID</span><br>HandleToUlong(PsGetProcessId(processObject));<span class="hljs-comment">//PID</span><br><br><span class="hljs-comment">// 要返回给请求者的状态码</span><br>Data-&gt;IoStatus.Status = ntStatus;<br>Data-&gt;IoStatus.Information = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 文件相关参数</span><br>FltObjects-&gt;Volume,<br>FltObjects-&gt;Instance,<br>FltObjects-&gt;FileObject,<br>FltObjects-&gt;FileObject-&gt;DeviceObject<br><br>Data-&gt;Iopb-&gt;Parameters.Create.SecurityContext-&gt;DesiredAccess<br><br>PVOIDpQueryBuffer = <br>Data-&gt;Iopb-&gt;Parameters.DirectoryControl.QueryDirectory.DirectoryBuffer;<br>ULONGuQueryBufferSize =  <br>Data-&gt;Iopb-&gt;Parameters.DirectoryControl.QueryDirectory.Length<br><br>PMDL pReadMdl     = Data-&gt;Iopb-&gt;Parameters.Read. MdlAddress;<br>PVOID pReadBuffer = Data-&gt;Iopb-&gt;Parameters.Read. ReadBuffer;<br>ULONG uReadLength = Data-&gt;Iopb-&gt;Parameters.Read.Length;<br><br><br>Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;<br>Data-&gt;IoStatus.Information = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> FLT_PREOP_COMPLETE;<br></code></pre></td></tr></table></figure><ul><li>路径获取</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在postcreate里获得</span><br><br>PFLT_FILE_NAME_INFORMATIONpNameInfo = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 这里没有分配内存，解析函数会分配内存，记得释放</span><br><br>ntStatus = FltGetFileNameInformation(Data,<br>FLT_FILE_NAME_NORMALIZED| <br>FLT_FILE_NAME_QUERY_DEFAULT,<br>&amp;pNameInfo);<br>FltParseFileNameInformation(pNameInfo);<br><br>pNameInfo-&gt;Name.Buffer <span class="hljs-comment">// 依然是一个设备名路径，依然有长短名之分</span><br>pNameInfo-&gt;Volume<br><br>FltReleaseFileNameInformation(pNameInfo); <span class="hljs-comment">//记得释放内存</span><br><br><span class="hljs-comment">// 重命名的获得：</span><br>PFILE_RENAME_INFORMATION <br>    pFileRenameInfomation = (PFILE_RENAME_INFORMATION)Data-&gt;Iopb-&gt;Parameters.SetFileInformation.InfoBuffer;<br><br>或者使用这个函数 FltGetDestinationFileNameInformation <span class="hljs-comment">//重命名获得</span><br></code></pre></td></tr></table></figure><ul><li><p>Pre和Post函数的 IRQL</p><ul><li>  a preoperation callback routine can be called at IRQL = PASSIVE_LEVEL or at IRQL = APC_LEVEL. Typically it is called at IRQL = PASSIVE_LEVEL</li><li>  If a minifilter driver’s preoperation callback routine returns FLT_PREOP_SYNCHRONIZE for an IRP-based I/O operation, the corresponding postoperation callback routine is called at IRQL &lt;= APC_LEVEL, in the same thread context as the preoperation callback routine. </li><li>  The postoperation callback routine for a fast I/O operation is called at IRQL = PASSIVE_LEVEL, in the same thread context as the preoperation callback routine. </li><li>  Post-create callback routines are called at IRQL = PASSIVE_LEVEL, in the context of the thread that originated the IRP_MJ_CREATE operation. </li></ul></li><li><p>minifilter中的文件操作：使用 FLT 系列函数，防止重入</p><ul><li>  FltCreateFile</li><li>  FltReadFile</li><li>  FltWriteFile</li><li>  FltClose</li><li>  FltQueryXXXX</li><li>  FltSetXXXX</li><li>  FltGetXXXX</li><li>  FltPerformXXXx</li></ul></li><li><p>上下文概念</p><ul><li>先复习一下传统过滤设备中的设备扩展概念，我们可以在创建设备的时候生成设备扩展，可以在设备扩展中记录一些跟当前设备有关的信息，在minifilter中，这就是context上下文。<ul><li>  申请：<code>FltAllocateContext(g_pFilter, FLR_INSTANCE_CONTEXT, SIZE, PAGEDPOOL, &amp;pInstanceText)</code></li><li>  释放：<code>FltReleaseContext(pInstanceText)</code>：<strong>使用引用计数管理，当计数为0时，会调用在注册minifilter时提供的contextRegistron的清理函数。</strong>（因为我们申请的context内部还有可能是指针，句柄等）</li></ul></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 上下文的内容由我们自己定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">INSTANCE_CONTEXT</span> &#123;</span><br>…<br>&#125; INSTANCE_CONTEXT, *PINSTANCE_CONTEXT;<br><br><span class="hljs-comment">//分配与设置</span><br>PINSTANCE_CONTEXT pContext = <span class="hljs-literal">NULL</span>;<br>ntStatus = FltGetInstanceContext(FltObjects-&gt;Instance, &amp; pContext);<br><span class="hljs-keyword">if</span>(NT_SUCCESS(Status) == FALSE)<br>&#123;<br>ntStatus = FltAllocateContext(g_pFilter,FLT_INSTANCE_CONTEXT,<br><span class="hljs-keyword">sizeof</span>(INSTANCE_CONTEXT),<br>PagedPool,&amp; pContext);<br><span class="hljs-keyword">if</span>(NT_SUCCESS(Status) == FALSE)<br>&#123;<br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br>RtlZeroMemory(pContext, <span class="hljs-keyword">sizeof</span>(INSTANCE_CONTEXT));<br>&#125;<br><span class="hljs-comment">// 分配完，存储一下自定义的数据</span><br>pContext -&gt;m_DeviceType = VolumeDeviceType;<br>pContext-&gt;m_FSType = VolumeFilesystemType;<br>FltSetInstanceContext(FltObjects-&gt;Instance, FLT_SET_CONTEXT_REPLACE_IF_EXISTS,pContext,<span class="hljs-literal">NULL</span>);<span class="hljs-comment">// 引用计数加一</span><br><span class="hljs-keyword">if</span> (pContext)<br>&#123;<br>FltReleaseContext(pContext);<span class="hljs-comment">//引用计数减一</span><br>&#125;<br><br><span class="hljs-comment">//获取访问</span><br>PINSTANCE_CONTEXT pContext = <span class="hljs-literal">NULL</span>;<br>Status = FltGetInstanceContext(FltObjects-&gt;Instance,&amp;pContext);<br>pContext-&gt;xxx = xxx;<br></code></pre></td></tr></table></figure><ul><li><p>分类</p><ul><li><p>Stream context 流上下文：对应 Fcb 文件控制块，一个文件在系统中只有一个文件控制块</p><ul><li>  <code>FltGetStreamContext</code></li><li>  <code>FltSetStreamContext</code></li></ul></li><li><p>Stream Handle context 流句柄上下文：对应fileObject，一个文件可以被打开多次，每次对应一个文件对象</p><ul><li>  <code>FltGetStreamHandleContext</code></li><li>  <code>FltSetStreamHandleContext</code></li><li>  可以在这里记录写关闭信息</li></ul></li><li><p>Instance context 实例上下文：对应在sfilter中为每个文件系统设备栈创建的一个过滤设备实例，与卷上下文一一对应，一般使用本上下文。</p><ul><li>  <code>FltGetInstanceContext</code></li><li>  <code>FltSetInstanceContext</code></li></ul></li><li><p>Volume Context 卷上下文：卷就是通常看到的 CDE盘，以及网络重定向器。一般情况下一个卷对应一个过滤器实例对象，实际应用中经常用实例上下文代替卷上下文。</p><ul><li>  <code>FltGetVolumeContext</code></li><li>  <code>FltSetVolumeContext</code></li></ul></li><li><p>文件上下文（vista之后）：没咋用过</p><ul><li>  <code>FltGetFileContext</code></li><li>  <code>FltSetFileContext</code></li></ul></li></ul></li></ul><h3 id="minifilter-中的通讯框架-太方便了"><a href="#minifilter-中的通讯框架-太方便了" class="headerlink" title="minifilter 中的通讯框架(太方便了)"></a>minifilter 中的通讯框架(太方便了)</h3></li><li><p>基于port的r0与r3通信</p><ul><li><p>  框架：分为r3主动还是r0主动<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210415105118.png" alt="image-20210408093619794"></p></li><li><p>r3 主动与r0 通信：</p><ul><li>  r0建立通信端口</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">FltCreateCommunicationPort(g_pFiter, <br>                           &amp;oa(端口名字), <br>                           <span class="hljs-literal">NULL</span>, <br>                           fnConnectFromClient, <span class="hljs-comment">// 获得r3端口</span><br>                           fnDisconnectFromClient, <span class="hljs-comment">// 断开连接处理</span><br>                           fnMessageFromClient);<span class="hljs-comment">// 处理从R3 FilterSendMessage的请求r3连接通信端口</span><br></code></pre></td></tr></table></figure><ul><li>  r3主动连接，发送消息</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">FilterConnectCommunicationPort( ScannerPortName,<span class="hljs-comment">//与R0的名字一致</span><br>                                                <span class="hljs-number">0</span>,<br>                                 <span class="hljs-literal">NULL</span>,<br>                                                <span class="hljs-number">0</span>,<br>                                                <span class="hljs-literal">NULL</span>,<br>                                                &amp;Port );<span class="hljs-comment">//R0端口</span><br><span class="hljs-comment">//主动发请求给R0</span><br> FilterSendMessage(<br>Port,<br>request,<br><span class="hljs-keyword">sizeof</span>(REQUEST),<br>reply ? reply : <span class="hljs-literal">NULL</span>,<br>reply ? <span class="hljs-keyword">sizeof</span>(REPLY) : <span class="hljs-number">0</span>,<br>&amp;dwRtn);<br><br></code></pre></td></tr></table></figure><ul><li>  r0处理消息（类似DeviceIoControl，使用Neither IO 方式，需要 ProbeXXXX ，并且 try 块包含）</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">NTSTATUS<br>fnMessageFromClient(<br>      IN PVOID PortCookie,<br>      IN PVOID InputBuffer OPTIONAL,<br>      IN ULONG InputBufferLength,<br>      OUT PVOID OutputBuffer OPTIONAL,<br>      IN ULONG OutputBufferLength,<br>      OUT PULONG ReturnOutputBufferLength<br>      )<br>&#123;<br>__try<br>&#123;<br>ProbeForRead(InputBuffer, InputBufferLength, <span class="hljs-keyword">sizeof</span>(ULONG));<br><span class="hljs-comment">//GET InputBuffer</span><br><span class="hljs-comment">//Do something</span><br>ProbeForWrite(OutputBuffer, OutputBufferLength, <span class="hljs-keyword">sizeof</span>(ULONG));<br><span class="hljs-comment">//Copy Result to Outputbuffer</span><br>&#125;<br>__except(EXCEPTION_EXECUTE_HANDLER)<br>&#123;<br><span class="hljs-keyword">return</span> STATUS_NOT_IMPLEMENTED;<br>&#125;<br><br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>r0主动与r3通信（主要）</p><ul><li>  r0 建立通信端口</li><li>  r3 连接通信端口</li><li>  r0 向客户端端口发送数据</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FltSendMessag(g_pFilter, &amp;g_pClientPort, &amp;request, requestSize, &amp;reply, replySize, &amp;timeOut);<br></code></pre></td></tr></table></figure><ul><li>  r3 等待通信，处理之后回复r0</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">FilterConnectCommunicationPort( ScannerPortName,<span class="hljs-comment">//与R0的名字一致</span><br>                                                <span class="hljs-number">0</span>,<br>                                 <span class="hljs-literal">NULL</span>,<br>                                                <span class="hljs-number">0</span>,<br>                                                <span class="hljs-literal">NULL</span>,<br>                                                &amp;Port );<span class="hljs-comment">//R0端口</span><br><br><span class="hljs-comment">//处理从R0来的请求，即R0调用FltSendMessage的请求 使用IOCP模型</span><br>completion = CreateIoCompletionPort( port,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>FilterGetMessage( Port,<br>&amp;message-&gt;MessageHeader,<br>FIELD_OFFSET( SANDBOX_MESSAGE, Ovlp ),<br>&amp;message-&gt;Ovlp ); <span class="hljs-comment">// 异步调用，下面使用GetQueuedCompletionStatus来等待r0消息</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 这里一直阻塞直到r0有消息发来</span><br>GetQueuedCompletionStatus(Completion, &amp;outSize, &amp;key, &amp;pOvlp, INFINITE );<br><br><span class="hljs-comment">// 用户弹窗等处理。。。</span><br>FilterReplyMessage(Port,<br>(PFILTER_REPLY_HEADER) &amp;replyMessage,<br><span class="hljs-keyword">sizeof</span>( replyMessage ) );<span class="hljs-comment">// 这里r0会接收到消息， fnMessageFromClient 进行处理</span><br>FilterGetMessage( Port,<br>&amp;message-&gt;MessageHeader,<br>FIELD_OFFSET( SANDBOX_MESSAGE, Ovlp ),<br>&amp;message-&gt;Ovlp ); <span class="hljs-comment">// 再次发起异步请求。</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>  从 CALL_BACK_DATA 中获取R3的缓冲区</p></li></ul><h3 id="Minifilter-sample-Scanner-代码解析"><a href="#Minifilter-sample-Scanner-代码解析" class="headerlink" title="Minifilter sample Scanner 代码解析"></a>Minifilter sample Scanner 代码解析</h3><ul><li>  简介：检测 txt inf doc cmd bat这些后缀文件中打开，写，写关闭时是否有病毒字符串“foul”</li><li>驱动<ul><li>驱动入口<ul><li>  创建安全描述符，仅允许amdin和system用户打开通讯端口</li><li>  创建通讯端口（示例代码没有注册接收r3消息的函数，可以添加函数，接收r3动态下发规则）</li><li>  启动过滤</li></ul></li><li>  ScannerPortConnect：接收客户端连接（此时可以进行连接校验），保存客户端process结构和客户端端口，方便之后使用。</li><li>  ScannerPortDisConnect：断开客户端连接</li><li>拦截IRP<ul><li>  precreate</li><li>  postcreate：判断是否是感兴趣的文件，扫描文件内容发给r3判断，如果r3拒绝，取消当前irp。判断当前打开方式是否是写打开，如果是，申请流句柄上下文，存储写相关的信息</li><li>PreWrite<ul><li>  没有客户端连接，直接返回</li><li>  获取流句柄上下文：如果获取失败，说明不是Scanner感兴趣的数据，直接返回</li><li>获取缓冲<ul><li>   如果data-&gt;iopb-&gt;parameters.write.mdladdress 不为空，说明该使用的就是direct io，使用mmgetsystemaddresformdlsafe 构建内核地址</li><li>  如果mdladdress为空，直接使用data-&gt;iopb-&gt;parameters.write.writebuffer</li><li>  申请空间，拷贝buffer到空间中，注意要try包含，使用了用户空间地址</li><li>  发送r3判断。。。</li></ul></li></ul></li><li>precleanup<ul><li>  没有客户端连接，直接返回</li><li>  获取流句柄上下文：如果获取失败，说明不是Scanner感兴趣的数据，直接返回</li><li>判断是否是写关闭<ul><li>  打开文件，读取文件，发送r3判断</li><li>  也可以直接发送文集路径给r3，由r3去全权操作。</li></ul></li><li>根据结果<ul><li>  有问题：删除，询问，放入隔离区</li></ul></li></ul></li></ul></li><li>获取信息，发送r3判断<ul><li>  获取扇区大小，仅读取固定的大小的数据去判断</li><li>  申请空间</li><li>  读文件内容</li><li>  发送信息，等待r3判断</li><li>  函数返回，表示是否允许</li></ul></li></ul></li><li>  应用程序</li></ul><h3 id="Minifilter-安装与运行"><a href="#Minifilter-安装与运行" class="headerlink" title="Minifilter 安装与运行"></a>Minifilter 安装与运行</h3><ul><li>有写好的inf文件<ul><li>  可以使用SetupCopyOEMInf 函数来安装</li><li>  可以右键单击inf安装</li></ul></li><li>代码安装<ul><li>  创建Instances 子键</li><li>创建Default Instance 子键<ul><li>  创建键值 Altitude “xxxxx”</li></ul></li></ul></li><li>控制 minifilter<ul><li>启动<ul><li>  net start Nullfilter</li><li>  sc start Nullfilter</li><li>  fltmc load nullfilter</li></ul></li><li>停止<ul><li>  net stop nullfilter</li><li>  sc stop nullfilter</li><li>  fltmc unload nullfilter</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows驱动开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows驱动开发</tag>
      
      <tag>Minifilter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sfilter过滤框架复习</title>
    <link href="/2021/04/07/sfilter%E8%BF%87%E6%BB%A4%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/"/>
    <url>/2021/04/07/sfilter%E8%BF%87%E6%BB%A4%E6%A1%86%E6%9E%B6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="sfilter框架主要流程"><a href="#sfilter框架主要流程" class="headerlink" title="sfilter框架主要流程"></a>sfilter框架主要流程</h3><ul><li>  创建控制设备：注意设备名</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">RtlInitUnicodeString( &amp;nameString, <span class="hljs-string">L&quot;\\FileSystem\\Filters\\SFilterDrv&quot;</span> );<br>或者<br>RtlInitUnicodeString( &amp;nameString, <span class="hljs-string">L&quot;\\FileSystem\\SFilterDrv&quot;</span> );<br></code></pre></td></tr></table></figure><ul><li>  创建控制设备符号链接</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">RtlInitUnicodeString(&amp;dosName, <span class="hljs-string">L&quot;\\DosDevices\\SFilterDrv&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><p>  设置过滤分发函数</p></li><li><p>  fastio：禁用 fastio</p></li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210407202302.png" alt="禁用FastIo"></p><ul><li><p>过滤与绑定</p><ul><li>IoRegisterFsRegistrationChange ：注册回调函数<ul><li>  当文件系统驱动被加载时，会调用这个回调函数，此时可以绑定文件系统设备以便过滤卷设备绑定的irp，新生成的过滤设备的flag要和文件系统设备的flag一致。之后设置设备完成初始化标记，可以处理irp了，DriverEntry中创建的设备对象会自动完成初始化，这里要手动初始化。</li></ul></li><li>SfFsControl：处理主功能号为<code>IRP_MJ_FILE_SYSTEM_CONTROL</code>    次功能号为 <code>IRP_MN_MOUNT_VOLUME</code>的 IRP， 在此IRP<strong>完成</strong>之后绑定卷设备。此时卷设备并没有生成，所以我们要完成当前 IRP，设置回调例程，IRP完成之后再绑定。<ul><li>  XP及其以后：回调例程 IRQL 为 PASSIVE_LEVEL 级别，可以直接设置事件状态。</li><li>  2000及之前：完成里程中的 IRQL 较高，所以要生成一个workitem，在工作项中设置事件状态。</li><li>  注意：回调例程中要返回 STATUS_MORE_PROCESSING_REQUIRED ，否则再访问 IRPSP 可能会蓝屏。</li></ul></li><li>  在文件系统回调中，创建文件系统的过滤设备，目的是为了过滤文件系统驱动的 <code>IRP_MJ_FILE_SYSTEM_CONTROL</code>    请求，<strong>在这个请求中创建过滤设备绑定得到的卷设备对象</strong></li></ul></li><li><p>不推荐卸载操作</p><ul><li>  卸载时，有些 IRP 可能处于 Pending 状态，如果驱动此时被卸载，那么将会执行不在内存中的代码引发蓝屏</li><li>解决方法：<ul><li>  使用两个驱动，一个业务驱动，一个过滤驱动，业务驱动向过滤驱动注册过滤请求，过滤驱动收到要过滤的消息发给业务处理，卸载时只需卸载业务驱动。</li><li>  使用 Minifilter 过滤框架~</li></ul></li></ul></li><li><p>SfCreate</p><ul><li>在 Create 时，IRP 还没有完成，要等待 IRP 完成之后，再获取文件名。<ul><li>  设置完成例程，再次强调完成例程中返回 <code>STATUS_MORE_PROCESSING_REQUIRED</code> ，因为还要再次访问 IRP。</li></ul></li><li>  必须在文件打开创建的时候获取文件名，在其它时候获取文件名可能是错误的。</li><li>  拿到文件名之后可以以 fileobject 插入哈希表，并记录打开方式，方便之后处理（关闭时判断是否是写关闭）。</li></ul></li><li><p>过滤驱动的几种操作</p><ul><li>  对 IRP 的结果感兴趣（刚刚才说过的在 Create 之后获取文件路径）</li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">    KeInitializeEvent( &amp;waitEvent, NotificationEvent, FALSE );<br>    <br>    IoCopyCurrentIrpStackLocationToNext ( Irp );<br>    <br>    IoSetCompletionRoutine( Irp, SfFsControlCompletion,&amp;waitEvent,TRUE,TRUE,TRUE );<br>    <br>    status = IoCallDriver( devExt-&gt;NLExtHeader.AttachedToDeviceObject, Irp );<br>    <br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">//  Wait for the operation to complete</span><br>    <span class="hljs-comment">//</span><br>    <br>    <span class="hljs-keyword">if</span> (STATUS_PENDING == status) &#123;<br>    <br>    status = KeWaitForSingleObject( &amp;waitEvent,<br>                                                Executive,<br>                                                KernelMode,<br>                                                FALSE,<br>                                                <span class="hljs-literal">NULL</span> );<br>    ASSERT( STATUS_SUCCESS == status );<br>    &#125;<br>    <br><br>    <span class="hljs-comment">// IRP完成之后返回了 STATUS_MORE_PROCESSING_REQUIRED 还要手动调用</span><br>IoCompleteRequest( Irp, IO_NO_INCREMENT );<br></code></pre></td></tr></table></figure><ul><li>  对 IRP 的结果不感兴趣</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">    IoSkipCurrentIrpStackLocation( Irp );<br><span class="hljs-keyword">return</span> IoCallDriver( devExt-&gt;NLExtHeader.AttachedToDeviceObject, Irp );<br></code></pre></td></tr></table></figure><pre><code>-   直接完成 IRP<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">Irp-&gt;IoStatus.Information = <span class="hljs-number">0</span>;<br>Irp-&gt;IoStatus.Status = status;<br>IoCompleteRequest( Irp, IO_NO_INCREMENT );<br></code></pre></td></tr></table></figure></code></pre><h3 id="基于SFilter的Hips实现"><a href="#基于SFilter的Hips实现" class="headerlink" title="基于SFilter的Hips实现"></a>基于SFilter的Hips实现</h3><ul><li>一般需要拦截的 IRP<ul><li>  FilterCreate（创建）</li><li>  FilterWrite（修改，加解密处理）</li><li>  FilterSetInfo（删，重命名）</li><li>  FilterClean（写关闭等）</li></ul></li><li>HIPS 框架<ul><li>驱动入口<ul><li>  获取系统进程的 PID，方便之后放行。</li><li>  分配各种需要的资源，锁等。</li></ul></li><li>SfCreate<ul><li>需要放行的一些情况<ul><li>  内核的请求：Irp-&gt;RequetorMode == KernelMode</li><li>  系统进程的请求：驱动入口中已经保存了系统进程的id</li><li>文件夹：<ul><li>  ulOptions = IrpStack-&gt;Parameters.Create.Options ;</li><li>  FlagOn(IrpStack-&gt;FileObject-&gt;Flags, FO_VOLUME_OPEN) ||</li><li>  FlagOn(ulOptions, FILE_DIRECTORY_FILE) ||</li><li>  FlagOn(IrpStack-&gt;Flags, SL_OPEN_PAGING_FILE)</li></ul></li><li>分页IO<ul><li>  (Irp-&gt;Flags &amp; IRP_PAGING_IO) </li><li>  (Irp-&gt;Flags &amp; IRP_SYNCHRONOUS_PAGING_IO) </li></ul></li></ul></li><li>放了该放行的之后，获取文件路径<ul><li>  有短名的话就转换长命</li><li>  设备名转符号链接名</li><li>  根据规则，进行匹配，判断是否通知用户</li></ul></li><li>  获取用户结果</li><li>  根据用户选择来选择阻止（直接结束IRP）或允许（设置完成例程，如果 IRP 成功，插入哈希表，方便之后做判断）</li></ul></li><li>SfWrite<ul><li>需要放行的一些情况<ul><li>APC_LEVEL：(Irp-&gt;Flags &amp; IRP_PAGING_IO) ||<br>  (Irp-&gt;Flags &amp; IRP_SYNCHRONOUS_PAGING_IO) </li><li>  系统线程：PsGetCurrentProcessId() == g_hSystemProcID </li><li>分页IO<ul><li>  (lpIrp-&gt;Flags &amp; IRP_PAGING_IO)</li><li>  (lpIrp-&gt;Flags &amp; IRP_SYNCHRONOUS_PAGING_IO)</li></ul></li></ul></li><li>  通过文件对象查找哈希表之前存入的数据</li><li>  拿到文件路径，开始对规则进行模式匹配</li><li>  获取用户选择</li><li>  根据选择来判断是禁止（直接IoCompleteRequest）还是允许（直接 IoSkipCurrentIrpStackLocation ）</li></ul></li><li>SfSetInfo<ul><li>  要拦截的 IRP 类型是 <code>FileRenameInformation</code> 和 <code>FileDispositionInformation</code></li><li>  是删除和重命名的话，我们对 IRP 的结果还是关心的，要根据 IRP 的结果来更新哈希表中的数据，或者删除。</li></ul></li><li>SfCleanUP<ul><li>  在创建的时候，将写标记放到哈希表中，关闭时，查看哈希表是否是写关闭。</li><li>  在写关闭时，再次扫描写入的数据，防止病毒<strong>分次</strong>写入数据。</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows驱动开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows驱动开发</tag>
      
      <tag>sfilter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>过滤驱动中和常用工具函数</title>
    <link href="/2021/04/07/%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"/>
    <url>/2021/04/07/%E8%BF%87%E6%BB%A4%E9%A9%B1%E5%8A%A8%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="符号链接名转设备链接名"><a href="#符号链接名转设备链接名" class="headerlink" title="符号链接名转设备链接名"></a>符号链接名转设备链接名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//输入\\??\\c:--&gt;\\device\\\harddiskvolume1</span><br><span class="hljs-comment">//LinkTarget.Buffer注意要释放</span><br><br><span class="hljs-function">NTSTATUS <span class="hljs-title">QuerySymbolicLink</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">IN PUNICODE_STRING SymbolicLinkName,</span></span><br><span class="hljs-function"><span class="hljs-params">OUT PUNICODE_STRING LinkTarget</span></span><br><span class="hljs-function"><span class="hljs-params">)</span>                                  </span><br><span class="hljs-function"></span>&#123;<br>OBJECT_ATTRIBUTESoa= &#123;<span class="hljs-number">0</span>&#125;;<br>NTSTATUSstatus= <span class="hljs-number">0</span>;<br>HANDLEhandle= <span class="hljs-literal">NULL</span>;<br><br>InitializeObjectAttributes(<br>&amp;oa, <br>SymbolicLinkName,<br>OBJ_CASE_INSENSITIVE,<br><span class="hljs-number">0</span>, <br><span class="hljs-number">0</span>);<br><br>status = ZwOpenSymbolicLinkObject(&amp;handle, GENERIC_READ, &amp;oa);<br><span class="hljs-keyword">if</span> (!NT_SUCCESS(status))<br>&#123;<br><span class="hljs-keyword">return</span> status;<br>&#125;<br><br>LinkTarget-&gt;MaximumLength = MAX_PATH*<span class="hljs-keyword">sizeof</span>(WCHAR);<br>LinkTarget-&gt;Length = <span class="hljs-number">0</span>;<br>LinkTarget-&gt;Buffer = ExAllocatePoolWithTag(PagedPool, LinkTarget-&gt;MaximumLength,&#x27;SOD&#x27;);<br><span class="hljs-keyword">if</span> (!LinkTarget-&gt;Buffer)<br>&#123;<br>ZwClose(handle);<br><span class="hljs-keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;<br>&#125;<br><br>RtlZeroMemory(LinkTarget-&gt;Buffer, LinkTarget-&gt;MaximumLength);<br><br>status = ZwQuerySymbolicLinkObject(handle, LinkTarget, <span class="hljs-literal">NULL</span>);<br>ZwClose(handle);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(status))<br>&#123;<br>ExFreePool(LinkTarget-&gt;Buffer);<br>&#125;<br><br><span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-comment">//\\??\\c:\\windows\\hi.txt--&gt;\\device\\harddiskvolume1\\windows\\hi.txt</span><br><br><span class="hljs-function">BOOL <span class="hljs-title">QueryVolumeName</span><span class="hljs-params">(WCHAR ch, WCHAR * name, USHORT size)</span></span><br><span class="hljs-function"></span>&#123;<br>WCHAR szVolume[<span class="hljs-number">7</span>] = <span class="hljs-string">L&quot;\\??\\C:&quot;</span>;<br>UNICODE_STRING LinkName;<br>UNICODE_STRING VolName;<br>UNICODE_STRING ustrTarget;<br>NTSTATUS ntStatus = <span class="hljs-number">0</span>;<br><br>RtlInitUnicodeString(&amp;LinkName, szVolume);<br><br>szVolume[<span class="hljs-number">4</span>] = ch;<br><br>ustrTarget.Buffer = name;<br>ustrTarget.Length = <span class="hljs-number">0</span>;<br>ustrTarget.MaximumLength = size;<br><br>ntStatus = QuerySymbolicLink(&amp;LinkName, &amp;VolName);<br><span class="hljs-keyword">if</span> (NT_SUCCESS(ntStatus))<br>&#123;<br>RtlCopyUnicodeString(&amp;ustrTarget, &amp;VolName);<br>ExFreePool(VolName.Buffer);<br>&#125;<br><span class="hljs-keyword">return</span> NT_SUCCESS(ntStatus);<br><br>&#125;<br><br><span class="hljs-function">BOOL NTAPI <span class="hljs-title">GetNtDeviceName</span><span class="hljs-params">(IN WCHAR * filename, OUT WCHAR * ntname)</span></span><br><span class="hljs-function"></span>&#123;<br>UNICODE_STRING uVolName = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>WCHAR volName[MAX_PATH] = <span class="hljs-string">L&quot;&quot;</span>;<br>WCHAR tmpName[MAX_PATH] = <span class="hljs-string">L&quot;&quot;</span>;<br>WCHAR chVol = <span class="hljs-string">L&#x27;\0&#x27;</span>;<br>WCHAR * pPath = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br><br>RtlStringCbCopyW(tmpName, MAX_PATH * <span class="hljs-keyword">sizeof</span>(WCHAR), filename);<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; MAX_PATH - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span>(tmpName[i] == <span class="hljs-string">L&#x27;:&#x27;</span>)<br>&#123;<br>pPath = &amp;tmpName[(i + <span class="hljs-number">1</span>) % MAX_PATH];<br>chVol = tmpName[i - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span>(pPath == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-keyword">if</span>(chVol == <span class="hljs-string">L&#x27;?&#x27;</span>)<br>&#123;<br>uVolName.Length = <span class="hljs-number">0</span>;<br>uVolName.MaximumLength = MAX_PATH * <span class="hljs-keyword">sizeof</span>(WCHAR);<br>uVolName.Buffer = ntname;<br>RtlAppendUnicodeToString(&amp;uVolName, <span class="hljs-string">L&quot;\\Device\\HarddiskVolume?&quot;</span>);<br>RtlAppendUnicodeToString(&amp;uVolName, pPath);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(QueryVolumeName(chVol, volName, MAX_PATH * <span class="hljs-keyword">sizeof</span>(WCHAR)))<br>&#123;<br>uVolName.Length = <span class="hljs-number">0</span>;<br>uVolName.MaximumLength = MAX_PATH * <span class="hljs-keyword">sizeof</span>(WCHAR);<br>uVolName.Buffer = ntname;<br>RtlAppendUnicodeToString(&amp;uVolName, volName);<br>RtlAppendUnicodeToString(&amp;uVolName, pPath);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="设备链接名转符号连接名"><a href="#设备链接名转符号连接名" class="headerlink" title="设备链接名转符号连接名"></a>设备链接名转符号连接名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//c:\\windows\\hi.txt&lt;--\\device\\harddiskvolume1\\windows\\hi.txt</span><br><span class="hljs-function">BOOL NTAPI <span class="hljs-title">GetNTLinkName</span><span class="hljs-params">(IN WCHAR * wszNTName, OUT WCHAR * wszFileName)</span></span><br><span class="hljs-function"></span>&#123;<br>UNICODE_STRINGustrFileName = &#123;<span class="hljs-number">0</span>&#125;;<br>UNICODE_STRINGustrDosName = &#123;<span class="hljs-number">0</span>&#125;;<br>UNICODE_STRINGustrDeviceName = &#123;<span class="hljs-number">0</span>&#125;;<br><br>WCHAR*pPath = <span class="hljs-literal">NULL</span>;<br>ULONGi = <span class="hljs-number">0</span>;<br>ULONGulSepNum = <span class="hljs-number">0</span>;<br><br><br><span class="hljs-keyword">if</span> (wszFileName == <span class="hljs-literal">NULL</span> ||<br>wszNTName == <span class="hljs-literal">NULL</span> ||<br>_wcsnicmp(wszNTName, <span class="hljs-string">L&quot;\\device\\harddiskvolume&quot;</span>, wcslen(<span class="hljs-string">L&quot;\\device\\harddiskvolume&quot;</span>))!=<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>ustrFileName.Buffer = wszFileName;<br>ustrFileName.Length = <span class="hljs-number">0</span>;<br>ustrFileName.MaximumLength = <span class="hljs-keyword">sizeof</span>(WCHAR)*MAX_PATH;<br><br><span class="hljs-keyword">while</span>(wszNTName[i]!=<span class="hljs-string">L&#x27;\0&#x27;</span>)<br>&#123;<br><br><span class="hljs-keyword">if</span> (wszNTName[i] == <span class="hljs-string">L&#x27;\0&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (wszNTName[i] == <span class="hljs-string">L&#x27;\\&#x27;</span>)<br>&#123;<br>ulSepNum++;<br>&#125;<br><span class="hljs-keyword">if</span> (ulSepNum == <span class="hljs-number">3</span>)<br>&#123;<br>wszNTName[i] = UNICODE_NULL;<br>pPath = &amp;wszNTName[i+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>i++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (pPath == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>RtlInitUnicodeString(&amp;ustrDeviceName, wszNTName);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(MyRtlVolumeDeviceToDosName(&amp;ustrDeviceName, &amp;ustrDosName)))<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>RtlCopyUnicodeString(&amp;ustrFileName, &amp;ustrDosName);<br>RtlAppendUnicodeToString(&amp;ustrFileName, <span class="hljs-string">L&quot;\\&quot;</span>);<br>RtlAppendUnicodeToString(&amp;ustrFileName, pPath);<br><br>ExFreePool(ustrDosName.Buffer);<br><br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-comment">//输入\\Device\\harddiskvolume1</span><br><span class="hljs-comment">//输出C:</span><br><span class="hljs-comment">//DosName.Buffer的内存记得释放</span><br><br>NTSTATUS<br>MyRtlVolumeDeviceToDosName(<br>IN PUNICODE_STRING DeviceName,<br>OUT PUNICODE_STRING DosName<br>)<br><br>&#123;<br>NTSTATUSstatus= <span class="hljs-number">0</span>;<br>UNICODE_STRINGdriveLetterName= &#123;<span class="hljs-number">0</span>&#125;;<br>WCHARdriveLetterNameBuf[<span class="hljs-number">128</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>WCHARc= <span class="hljs-string">L&#x27;\0&#x27;</span>;<br>WCHARDriLetter[<span class="hljs-number">3</span>]= &#123;<span class="hljs-number">0</span>&#125;;<br>UNICODE_STRINGlinkTarget= &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">for</span> (c = <span class="hljs-string">L&#x27;A&#x27;</span>; c &lt;= <span class="hljs-string">L&#x27;Z&#x27;</span>; c++)<br>&#123;<br>RtlInitEmptyUnicodeString(&amp;driveLetterName,driveLetterNameBuf,<span class="hljs-keyword">sizeof</span>(driveLetterNameBuf));<br>RtlAppendUnicodeToString(&amp;driveLetterName, <span class="hljs-string">L&quot;\\??\\&quot;</span>);<br>DriLetter[<span class="hljs-number">0</span>] = c;<br>DriLetter[<span class="hljs-number">1</span>] = <span class="hljs-string">L&#x27;:&#x27;</span>;<br>DriLetter[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>RtlAppendUnicodeToString(&amp;driveLetterName,DriLetter);<br><br>status = QuerySymbolicLink(&amp;driveLetterName, &amp;linkTarget);<br><span class="hljs-keyword">if</span> (!NT_SUCCESS(status))<br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (RtlEqualUnicodeString(&amp;linkTarget, DeviceName, TRUE))<br>&#123;<br>ExFreePool(linkTarget.Buffer);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>ExFreePool(linkTarget.Buffer);<br>&#125;<br><br><span class="hljs-keyword">if</span> (c &lt;= <span class="hljs-string">L&#x27;Z&#x27;</span>)<br>&#123;<br>DosName-&gt;Buffer = ExAllocatePoolWithTag(PagedPool, 3*sizeof(WCHAR), &#x27;SOD&#x27;);<br><span class="hljs-keyword">if</span> (!DosName-&gt;Buffer)<br>&#123;<br><span class="hljs-keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;<br>&#125;<br><br>DosName-&gt;MaximumLength = <span class="hljs-number">6</span>;<br>DosName-&gt;Length   = <span class="hljs-number">4</span>;<br>*DosName-&gt;Buffer  = c;<br>*(DosName-&gt;Buffer+ <span class="hljs-number">1</span>) = <span class="hljs-string">&#x27;:&#x27;</span>;<br>*(DosName-&gt;Buffer+ <span class="hljs-number">2</span>) = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">return</span> STATUS_SUCCESS;<br>&#125;<br><br><span class="hljs-keyword">return</span> status;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例</span><br>UNICODE_STRING uExpression = &#123;<span class="hljs-number">0</span>&#125;;<br>UNICODE_STRING uName   = &#123;<span class="hljs-number">0</span>&#125;;<br><br>RtlInitUnicodeString(&amp;uExpression, <span class="hljs-string">L&quot;C:\\WINDOWS\\SYSTEM32\\*.SYS&quot;</span>);<br>RtlInitUnicodeString(&amp;uName, <span class="hljs-string">L&quot;c:\\Windows\\system32\\122222\\2.sys&quot;</span>);<br><br><span class="hljs-keyword">if</span> (IsPatternMatch(&amp;uExpression, &amp;uName, TRUE))<br>&#123;<br>DbgPrint(<span class="hljs-string">&quot;Matched\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>DbgPrint(<span class="hljs-string">&quot;Not Matched\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function">BOOLEAN <span class="hljs-title">IsPatternMatch</span><span class="hljs-params">(PUNICODE_STRING Expression, PUNICODE_STRING Name, BOOLEAN IgnoreCase)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> FsRtlIsNameInExpression(<br>    Expression,<br>    Name,<br>    IgnoreCase,<span class="hljs-comment">//如果这里设置为TRUE,那么Expression必须是大写的</span><br>    <span class="hljs-literal">NULL</span><br>    ); <br><br>&#125;<br><br><span class="hljs-function">BOOL <span class="hljs-title">PatternMatch</span><span class="hljs-params">(WCHAR * pat, WCHAR * str)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">register</span> WCHAR * s;<br>   <span class="hljs-keyword">register</span> WCHAR * p;<br>   BOOL star = FALSE;<br><br>loopStart:<br>   <span class="hljs-keyword">for</span> (s = str, p = pat; *s; ++s, ++p) &#123;<br>      <span class="hljs-keyword">switch</span> (*p) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">L&#x27;?&#x27;</span>:<br>            <span class="hljs-keyword">if</span> (*s == <span class="hljs-string">L&#x27;.&#x27;</span>) <span class="hljs-keyword">goto</span> starCheck;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">L&#x27;*&#x27;</span>:<br>            star = TRUE;<br>            str = s, pat = p;<br>            <span class="hljs-keyword">if</span> (!*++pat) <span class="hljs-keyword">return</span> TRUE;<br>            <span class="hljs-keyword">goto</span> loopStart;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">//if (Lower(*s) != Lower(*p))</span><br>               <span class="hljs-keyword">goto</span> starCheck;<br>            <span class="hljs-keyword">break</span>;<br>      &#125; <br>   &#125; <br>   <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">L&#x27;*&#x27;</span>) ++p;<br>   <span class="hljs-keyword">return</span> (!*p);<br><br>starCheck:<br>   <span class="hljs-keyword">if</span> (!star) <span class="hljs-keyword">return</span> FALSE;<br>   str++;<br>   <span class="hljs-keyword">goto</span> loopStart;<br>&#125;<br><br><span class="hljs-function">BOOL <span class="hljs-title">PatternNMatch</span><span class="hljs-params">(WCHAR * pat, WCHAR * str, DWORD count)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">register</span> WCHAR * s;<br>   <span class="hljs-keyword">register</span> WCHAR * p;<br>   BOOL star = FALSE;<br>   DWORD dwCount = count;<br><br>loopStart:<br>   <span class="hljs-keyword">for</span> (s = str, p = pat; dwCount&gt;<span class="hljs-number">0</span>; --dwCount, ++s, ++p) &#123;<br>      <span class="hljs-keyword">switch</span> (*p) &#123;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">L&#x27;?&#x27;</span>:<br>            <span class="hljs-keyword">if</span> (*s == <span class="hljs-string">L&#x27;.&#x27;</span>) <span class="hljs-keyword">goto</span> starCheck;<br>            <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> <span class="hljs-string">L&#x27;*&#x27;</span>:<br>            star = TRUE;<br>            str = s, pat = p;<br>            <span class="hljs-keyword">if</span> (!*++pat) <span class="hljs-keyword">return</span> TRUE;<br>            <span class="hljs-keyword">goto</span> loopStart;<br>         <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">//if (Lower(*s) != Lower(*p))</span><br>               <span class="hljs-keyword">goto</span> starCheck;<br>            <span class="hljs-keyword">break</span>;<br>      &#125; <br>   &#125; <br>   <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">L&#x27;*&#x27;</span>) ++p;<br>   <span class="hljs-keyword">return</span> (!*p);<br><br>starCheck:<br>   <span class="hljs-keyword">if</span> (!star) <span class="hljs-keyword">return</span> FALSE;<br>   str++;<br>   dwCount--;<br>   <span class="hljs-keyword">goto</span> loopStart;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="短名转长名"><a href="#短名转长名" class="headerlink" title="短名转长名"></a>短名转长名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 示例</span><br><span class="hljs-comment">//dir /x看短名</span><br>WCHARwszShortName[MAX_PATH] =<span class="hljs-string">L&quot;\\??\\C:\\PROGRA~1\\COMMON~1\\MICROS~1\\VC\\1.txt&quot;</span>;<br>WCHARwszLongName[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-keyword">if</span>(ConverShortToLongName(wszLongName, wszShortName, <span class="hljs-keyword">sizeof</span>(wszLongName)))<br>&#123;<br>DbgPrint(<span class="hljs-string">&quot;%ws\n&quot;</span>, wszLongName);<br>&#125;<br><br><span class="hljs-function">BOOL <span class="hljs-title">IsRootDirecotry</span><span class="hljs-params">(WCHAR * wszDir)</span></span><br><span class="hljs-function"></span>&#123;<br>SIZE_T length = wcslen(wszDir);<br><br><span class="hljs-comment">// c:</span><br><span class="hljs-keyword">if</span>((length == <span class="hljs-number">2</span>) &amp;&amp; (wszDir[<span class="hljs-number">1</span>] == <span class="hljs-string">L&#x27;:&#x27;</span>))<br><span class="hljs-keyword">return</span> TRUE;<br><span class="hljs-comment">//\\??\\c:</span><br><span class="hljs-keyword">if</span>((length == <span class="hljs-number">6</span>) &amp;&amp; <br>(_wcsnicmp(wszDir, <span class="hljs-string">L&quot;\\??\\&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &amp;&amp;<br>(wszDir[<span class="hljs-number">5</span>] == <span class="hljs-string">L&#x27;:&#x27;</span>))<br><span class="hljs-keyword">return</span> TRUE;<br><span class="hljs-comment">//\\DosDevices\\c:</span><br><span class="hljs-keyword">if</span>((length == <span class="hljs-number">14</span>) &amp;&amp; <br>(_wcsnicmp(wszDir, <span class="hljs-string">L&quot;\\DosDevices\\&quot;</span>, <span class="hljs-number">12</span>) == <span class="hljs-number">0</span>) &amp;&amp;<br>(wszDir[<span class="hljs-number">13</span>] == <span class="hljs-string">L&#x27;:&#x27;</span>))<br><span class="hljs-keyword">return</span> TRUE;<br><span class="hljs-comment">//\\Device\\HarddiskVolume1</span><br><span class="hljs-keyword">if</span>((length == <span class="hljs-number">23</span>) &amp;&amp;<br>(_wcsnicmp(wszDir, <span class="hljs-string">L&quot;\\Device\\HarddiskVolume&quot;</span>, <span class="hljs-number">22</span>) == <span class="hljs-number">0</span>))<br><span class="hljs-keyword">return</span> TRUE;<br><br><br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><br><span class="hljs-function">BOOL <span class="hljs-title">IsDirectorySep</span><span class="hljs-params">(WCHAR ch)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (ch == <span class="hljs-string">L&#x27;\\&#x27;</span> || ch == <span class="hljs-string">L&#x27;/&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//C:\\Program\\123456~1</span><br><span class="hljs-comment">//wszRootdir为:c:\\Program</span><br><span class="hljs-comment">//wszShortName为：123456~1</span><br><br><span class="hljs-function">BOOL <span class="hljs-title">QueryDirectoryForLongName</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">  WCHAR * wszRootDir, </span></span><br><span class="hljs-function"><span class="hljs-params">  WCHAR * wszShortName, </span></span><br><span class="hljs-function"><span class="hljs-params">  WCHAR *wszLongName, </span></span><br><span class="hljs-function"><span class="hljs-params">  ULONG ulSize)</span></span><br><span class="hljs-function"></span>&#123;<br>UNICODE_STRINGustrRootDir= &#123;<span class="hljs-number">0</span>&#125;;<br>UNICODE_STRINGustrShortName= &#123;<span class="hljs-number">0</span>&#125;;<br>UNICODE_STRINGustrLongName= &#123;<span class="hljs-number">0</span>&#125;;<br>OBJECT_ATTRIBUTESoa= &#123;<span class="hljs-number">0</span>&#125;;<br>IO_STATUS_BLOCKIosb= &#123;<span class="hljs-number">0</span>&#125;;<br>NTSTATUSntStatus= <span class="hljs-number">0</span>;<br>HANDLEhDirHandle= <span class="hljs-number">0</span>;<br>BYTE*Buffer= <span class="hljs-literal">NULL</span>;<br>WCHAR*wszRoot= <span class="hljs-literal">NULL</span>;<br>PFILE_BOTH_DIR_INFORMATIONpInfo= <span class="hljs-literal">NULL</span>;<br><br>RtlZeroMemory(&amp;Iosb, <span class="hljs-keyword">sizeof</span>(IO_STATUS_BLOCK));<br>Iosb.Status = STATUS_NO_SUCH_FILE;<br><br>wszRoot = ExAllocatePoolWithTag(PagedPool,<br>  MAX_PATH * <span class="hljs-keyword">sizeof</span>(WCHAR),<br>  &#x27;L2S&#x27;);<br><span class="hljs-keyword">if</span>(wszRoot == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>RtlZeroMemory(wszRoot, MAX_PATH * <span class="hljs-keyword">sizeof</span>(WCHAR));<br><br>wcsncpy(wszRoot, wszRootDir, MAX_PATH);<br><br>RtlInitUnicodeString(&amp;ustrRootDir, wszRoot);<br>RtlInitUnicodeString(&amp;ustrShortName, wszShortName);<br><br><span class="hljs-keyword">if</span>(IsRootDirecotry(wszRoot))<br>RtlAppendUnicodeToString(&amp;ustrRootDir, <span class="hljs-string">L&quot;\\&quot;</span>);<br><br>InitializeObjectAttributes(&amp;oa,<br>   &amp;ustrRootDir,<br>   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,<br>   <span class="hljs-number">0</span>, <br>   <span class="hljs-number">0</span>);  <br><br>ntStatus = ZwCreateFile(&amp;hDirHandle,<br>GENERIC_READ | SYNCHRONIZE,<br>&amp;oa,<br>&amp;Iosb,<br><span class="hljs-number">0</span>, <br>FILE_ATTRIBUTE_DIRECTORY, <br>FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, <br>FILE_OPEN, <br>FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT , <br><span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) <br>&#123; <br>ExFreePool(wszRoot);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>ExFreePool(wszRoot);<br><br>Buffer = ExAllocatePoolWithTag(PagedPool,<br>  <span class="hljs-number">1024</span>,<br>  &#x27;L2S&#x27;);<br><span class="hljs-keyword">if</span>(Buffer == <span class="hljs-literal">NULL</span>)<br>&#123;<br>ZwClose(hDirHandle);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>RtlZeroMemory(Buffer, <span class="hljs-number">1024</span>);<br><br>ntStatus = ZwQueryDirectoryFile(hDirHandle,<br><span class="hljs-literal">NULL</span>,<br><span class="hljs-number">0</span>,<br><span class="hljs-number">0</span>,<br>&amp;Iosb,<br>Buffer,<br><span class="hljs-number">1024</span>,<br>FileBothDirectoryInformation,<br>TRUE,<br>&amp;ustrShortName, <span class="hljs-comment">//传回与 ustrShortName Match的项</span><br>TRUE);<br><br><span class="hljs-keyword">if</span> (!NT_SUCCESS(ntStatus)) <br>&#123;<br>ExFreePool(Buffer);<br>ZwClose(hDirHandle);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>ZwClose(hDirHandle);<br><br>pInfo = (PFILE_BOTH_DIR_INFORMATION) Buffer;<br><br><span class="hljs-keyword">if</span>(pInfo-&gt;FileNameLength == <span class="hljs-number">0</span>)<br>&#123;<br>ExFreePool(Buffer);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>ustrShortName.Length  = (USHORT)pInfo-&gt;FileNameLength;<br>ustrShortName.MaximumLength = (USHORT)pInfo-&gt;FileNameLength;<br>ustrShortName.Buffer = pInfo-&gt;FileName;<span class="hljs-comment">//长名</span><br><br><span class="hljs-keyword">if</span>(ulSize &lt; ustrShortName.Length)<br>&#123;<br>ExFreePool(Buffer);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>ustrLongName.Length = <span class="hljs-number">0</span>;<br>ustrLongName.MaximumLength = (USHORT)ulSize;<br>ustrLongName.Buffer = wszLongName;<br><br>RtlCopyUnicodeString(&amp;ustrLongName, &amp;ustrShortName);<br>ExFreePool(Buffer);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function">BOOL <span class="hljs-title">QueryLongName</span><span class="hljs-params">(WCHAR * wszFullPath, WCHAR * wszLongName, ULONG size)</span></span><br><span class="hljs-function"></span>&#123;<br>BOOLrtn= FALSE;<br>WCHAR *pchStart= wszFullPath;<br>WCHAR *pchEnd= <span class="hljs-literal">NULL</span>;<br>WCHAR *wszShortName= <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//c:\\Program\\Files1~1--&gt;获得Files1~1的长名</span><br><span class="hljs-keyword">while</span>(*pchStart)<br>&#123;<br><span class="hljs-keyword">if</span>(IsDirectorySep(*pchStart))<br>pchEnd = pchStart;<br><br>pchStart++;<br>&#125;<br><span class="hljs-comment">//wszFullPath=c:\\Program</span><br><span class="hljs-comment">//pchEnd = Files~1</span><br><br><span class="hljs-keyword">if</span>(pchEnd)<br>&#123;<br>*pchEnd++ = <span class="hljs-string">L&#x27;\0&#x27;</span>;<br><span class="hljs-comment">//c:\\Program\\Files1~1</span><br><span class="hljs-comment">//wszFullPath:c:\\Program</span><br><span class="hljs-comment">//pchEnd:Files1~1</span><br>wszShortName = pchEnd;<br>rtn = QueryDirectoryForLongName(wszFullPath, wszShortName, wszLongName, size);<br>*(--pchEnd) = <span class="hljs-string">L&#x27;\\&#x27;</span>;<br><span class="hljs-comment">//wszFullPath=c:\\Program\\Files1~1</span><br>&#125;<br><span class="hljs-keyword">return</span> rtn;<br>&#125;<br><br><span class="hljs-comment">//先把根目录拷贝到目标目录中，剩下的找到下一级目录是否含有~，如果有，则开始转化。</span><br><span class="hljs-comment">//如：c:\\Progam\\a~1\\b~1\hi~1.txt</span><br><span class="hljs-comment">//pchStart指向目录中前一个\\,pchEnd扫描并指向目录的下一个\\，其中如果发现了~，则是短名，需要转换。</span><br><span class="hljs-comment">//传c:\\Program\\a~1--&gt;c:\\Progam\\ax</span><br><span class="hljs-comment">//传c:\\Program\\ax\\b~1--&gt;c:\\Program\\ax\\by</span><br><span class="hljs-comment">//传c:\\Program\\ax\by\\hi~1.txt--&gt;c:\\Program\\ax\by\\hiz.txt</span><br><span class="hljs-function">BOOL <span class="hljs-title">ConverShortToLongName</span><span class="hljs-params">(WCHAR *wszLongName, WCHAR *wszShortName, ULONG size)</span></span><br><span class="hljs-function"></span>&#123;<br>WCHAR*szResult= <span class="hljs-literal">NULL</span>;<br>WCHAR*pchResult= <span class="hljs-literal">NULL</span>;<br>WCHAR*pchStart= wszShortName;<br>INTOffset= <span class="hljs-number">0</span>;<br>  <br>szResult = ExAllocatePoolWithTag(PagedPool,<br>  <span class="hljs-keyword">sizeof</span>(WCHAR) * (MAX_PATH * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>),<br>  &#x27;L2S&#x27;);<br><br><span class="hljs-keyword">if</span>(szResult == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>RtlZeroMemory(szResult, <span class="hljs-keyword">sizeof</span>(WCHAR) * (MAX_PATH * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>));<br>pchResult = szResult;<br><br><br><span class="hljs-comment">//C:\\x\\--&gt;\\??\\c:</span><br><span class="hljs-keyword">if</span> (pchStart[<span class="hljs-number">0</span>] &amp;&amp; pchStart[<span class="hljs-number">1</span>] == <span class="hljs-string">L&#x27;:&#x27;</span>) <br>&#123;<br>*pchResult++ = <span class="hljs-string">L&#x27;\\&#x27;</span>;<br>*pchResult++ = <span class="hljs-string">L&#x27;?&#x27;</span>;<br>*pchResult++ = <span class="hljs-string">L&#x27;?&#x27;</span>;<br>*pchResult++ = <span class="hljs-string">L&#x27;\\&#x27;</span>;<br>*pchResult++ = *pchStart++;<br>*pchResult++ = *pchStart++;<br>Offset = <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-comment">//\\DosDevices\\c:\\xx--&gt;\\??\\c:</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_wcsnicmp(pchStart, <span class="hljs-string">L&quot;\\DosDevices\\&quot;</span>, <span class="hljs-number">12</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>RtlStringCbCopyW(pchResult, <span class="hljs-keyword">sizeof</span>(WCHAR) * (MAX_PATH * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>), <span class="hljs-string">L&quot;\\??\\&quot;</span>);<br>pchResult += <span class="hljs-number">4</span>;<br>pchStart += <span class="hljs-number">12</span>;<br><span class="hljs-keyword">while</span> (*pchStart &amp;&amp; !IsDirectorySep(*pchStart))<br>*pchResult++ = *pchStart++;<br>Offset = <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-comment">//\\Device\\HarddiskVolume1\\xx--&gt;\\Device\\HarddiskVolume1</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_wcsnicmp(pchStart, <span class="hljs-string">L&quot;\\Device\\HardDiskVolume&quot;</span>, <span class="hljs-number">22</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>RtlStringCbCopyW(pchResult, <span class="hljs-keyword">sizeof</span>(WCHAR) * (MAX_PATH * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>),<span class="hljs-string">L&quot;\\Device\\HardDiskVolume&quot;</span>);<br>pchResult += <span class="hljs-number">22</span>;<br>pchStart += <span class="hljs-number">22</span>;<br><span class="hljs-keyword">while</span> (*pchStart &amp;&amp; !IsDirectorySep(*pchStart))<br>*pchResult++ = *pchStart++;<br>&#125;<br><span class="hljs-comment">//\\??\\c:\\xx--&gt;\\??\\c:</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_wcsnicmp(pchStart, <span class="hljs-string">L&quot;\\??\\&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>RtlStringCbCopyW(pchResult, <span class="hljs-keyword">sizeof</span>(WCHAR) * (MAX_PATH * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>), <span class="hljs-string">L&quot;\\??\\&quot;</span>);<br>pchResult += <span class="hljs-number">4</span>;<br>pchStart += <span class="hljs-number">4</span>;<br><br><span class="hljs-keyword">while</span> (*pchStart &amp;&amp; !IsDirectorySep(*pchStart))<br>*pchResult++ = *pchStart++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ExFreePool(szResult);<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-keyword">while</span> (IsDirectorySep(*pchStart)) <br>&#123;<br>BOOLbShortName= FALSE;<br>WCHAR*pchEnd= <span class="hljs-literal">NULL</span>;<br>WCHAR*pchReplacePos= <span class="hljs-literal">NULL</span>;<br><br>*pchResult++ = *pchStart++;<br><br>pchEnd = pchStart;<br>pchReplacePos = pchResult;<br><br><span class="hljs-keyword">while</span> (*pchEnd &amp;&amp; !IsDirectorySep(*pchEnd))<br>&#123;<br><span class="hljs-keyword">if</span>(*pchEnd == <span class="hljs-string">L&#x27;~&#x27;</span>)<br>&#123;<br>bShortName = TRUE;<br>&#125;<br><br>*pchResult++ = *pchEnd++;<br>&#125;<br><br>*pchResult = <span class="hljs-string">L&#x27;\0&#x27;</span>;<br>  <br><span class="hljs-keyword">if</span>(bShortName)<br>&#123;<br>WCHAR  * szLong = <span class="hljs-literal">NULL</span>;<br><br>szLong = ExAllocatePoolWithTag(PagedPool,<br>  <span class="hljs-keyword">sizeof</span>(WCHAR) * MAX_PATH,<br>  &#x27;L2S&#x27;);<br><span class="hljs-keyword">if</span>(szLong)<br>&#123;<br>RtlZeroMemory(szLong,  <span class="hljs-keyword">sizeof</span>(WCHAR) * MAX_PATH);<br><br><span class="hljs-keyword">if</span>(QueryLongName(szResult, szLong, <span class="hljs-keyword">sizeof</span>(WCHAR) * MAX_PATH))<br>&#123;<br>RtlStringCbCopyW(pchReplacePos, <span class="hljs-keyword">sizeof</span>(WCHAR) * (MAX_PATH * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>), szLong);<br>pchResult = pchReplacePos + wcslen(pchReplacePos);<br>&#125;<br><br>ExFreePool(szLong);<br>&#125;<br>&#125;<br><br>pchStart = pchEnd;<br>&#125;<br><br>wcsncpy(wszLongName, szResult + Offset, size/<span class="hljs-keyword">sizeof</span>(WCHAR));<br>ExFreePool(szResult);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><span class="hljs-function">BOOL <span class="hljs-title">IsShortNamePath</span><span class="hljs-params">(WCHAR * wszFileName)</span></span><br><span class="hljs-function"></span>&#123;<br></code></pre></td></tr></table></figure><h3 id="根据id获取进程全路径（1）"><a href="#根据id获取进程全路径（1）" class="headerlink" title="根据id获取进程全路径（1）"></a>根据id获取进程全路径（1）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">NTSTATUS  <span class="hljs-title">GetProcessFullNameByPid</span><span class="hljs-params">(HANDLE nPid, PUNICODE_STRING  FullPath)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    HANDLE               hFile      = <span class="hljs-literal">NULL</span>;<br>    ULONG                nNeedSize= <span class="hljs-number">0</span>;<br>    NTSTATUS             nStatus    = STATUS_SUCCESS;<br>    NTSTATUS             nDeviceStatus = STATUS_DEVICE_DOES_NOT_EXIST;<br>    PEPROCESS            Process    = <span class="hljs-literal">NULL</span>;<br>    KAPC_STATE           ApcState   = &#123;<span class="hljs-number">0</span>&#125;;<br>    PVOID                lpBuffer   = <span class="hljs-literal">NULL</span>;<br>    OBJECT_ATTRIBUTES ObjectAttributes = &#123;<span class="hljs-number">0</span>&#125;;<br>    IO_STATUS_BLOCK      IoStatus   = &#123;<span class="hljs-number">0</span>&#125;; <br>    PFILE_OBJECT         FileObject = <span class="hljs-literal">NULL</span>;<br>    PFILE_NAME_INFORMATION FileName = <span class="hljs-literal">NULL</span>;   <br>    WCHAR                FileBuffer[MAX_PATH] = &#123;<span class="hljs-number">0</span>&#125;;<br>    DECLARE_UNICODE_STRING_SIZE(ProcessPath,MAX_PATH);<br>    DECLARE_UNICODE_STRING_SIZE(DosDeviceName,MAX_PATH);<br>    <br>    PAGED_CODE();<br><br>    nStatus = PsLookupProcessByProcessId(nPid, &amp;Process);<br>    <span class="hljs-keyword">if</span>(NT_ERROR(nStatus))<br>    &#123;<br>        KdPrint((<span class="hljs-string">&quot;%s error PsLookupProcessByProcessId.\n&quot;</span>,__FUNCTION__));<br>        <span class="hljs-keyword">return</span> nStatus;<br>    &#125;<br><br><br><br>    __try<br>    &#123;<br><br>        KeStackAttachProcess(Process, &amp;ApcState);<br>        <br>        nStatus = ZwQueryInformationProcess(<br>            NtCurrentProcess(),<br>            ProcessImageFileName,<br>            <span class="hljs-literal">NULL</span>,<br>            <span class="hljs-literal">NULL</span>,<br>            &amp;nNeedSize<br>            );<br><br>        <span class="hljs-keyword">if</span> (STATUS_INFO_LENGTH_MISMATCH != nStatus)<br>        &#123;<br>            KdPrint((<span class="hljs-string">&quot;%s NtQueryInformationProcess error.\n&quot;</span>,__FUNCTION__)); <br>            nStatus = STATUS_MEMORY_NOT_ALLOCATED;<br>            __leave;<br><br>        &#125;<br><br>        lpBuffer = ExAllocatePoolWithTag(NonPagedPool, nNeedSize,&#x27;GetP&#x27;);<br>        <span class="hljs-keyword">if</span> (lpBuffer == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            KdPrint((<span class="hljs-string">&quot;%s ExAllocatePoolWithTag error.\n&quot;</span>,__FUNCTION__));<br>            nStatus = STATUS_MEMORY_NOT_ALLOCATED;<br>            __leave; <br>        &#125;<br><br>       nStatus =  ZwQueryInformationProcess(<br>           NtCurrentProcess(),<br>           ProcessImageFileName, <br>           lpBuffer, <br>           nNeedSize,<br>           &amp;nNeedSize<br>           );<br><br>       <span class="hljs-keyword">if</span> (NT_ERROR(nStatus))<br>       &#123;<br>           KdPrint((<span class="hljs-string">&quot;%s NtQueryInformationProcess error2.\n&quot;</span>,__FUNCTION__));<br>           __leave;<br>       &#125;<br><br>       RtlCopyUnicodeString(&amp;ProcessPath,(PUNICODE_STRING)lpBuffer);<br>       InitializeObjectAttributes(<br>           &amp;ObjectAttributes,<br>           &amp;ProcessPath,<br>           OBJ_CASE_INSENSITIVE,<br>           <span class="hljs-literal">NULL</span>,<br>           <span class="hljs-literal">NULL</span><br>           );<br><br>       nStatus = ZwCreateFile(<br>           &amp;hFile,<br>           FILE_READ_ATTRIBUTES,<br>           &amp;ObjectAttributes,<br>           &amp;IoStatus,<br>           <span class="hljs-literal">NULL</span>,<br>           FILE_ATTRIBUTE_NORMAL,<br>           <span class="hljs-number">0</span>,<br>           FILE_OPEN,<br>           FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE,<br>           <span class="hljs-literal">NULL</span>,<br>           <span class="hljs-number">0</span><br>           );  <br><br>       <span class="hljs-keyword">if</span> (NT_ERROR(nStatus))<br>       &#123;<br>           hFile = <span class="hljs-literal">NULL</span>;<br>           __leave;<br>       &#125;<br><br>       nStatus = ObReferenceObjectByHandle(<br>           hFile, <br>           <span class="hljs-literal">NULL</span>,<br>           *IoFileObjectType, <br>           KernelMode, <br>           (PVOID*)&amp;FileObject,<br>           <span class="hljs-literal">NULL</span><br>           );<br><br>       <span class="hljs-keyword">if</span> (NT_ERROR(nStatus))<br>       &#123;<br>           FileObject = <span class="hljs-literal">NULL</span>;<br>           __leave;<br>       &#125;<br>       <br>       FileName = (PFILE_NAME_INFORMATION)FileBuffer;<br>       <br>       nStatus = ZwQueryInformationFile(<br>           hFile,<br>           &amp;IoStatus,<br>           FileName,<br>           <span class="hljs-keyword">sizeof</span>(WCHAR)*MAX_PATH,<br>           FileNameInformation<br>           );<br><br>       <span class="hljs-keyword">if</span> (NT_ERROR(nStatus))<br>       &#123;<br>           __leave;<br>       &#125;<br><br>       <span class="hljs-keyword">if</span> (FileObject-&gt;DeviceObject == <span class="hljs-literal">NULL</span>)<br>       &#123;<br>           nDeviceStatus = STATUS_DEVICE_DOES_NOT_EXIST;<br>           __leave;<br>       &#125;<br><br>       nDeviceStatus = RtlVolumeDeviceToDosName(FileObject-&gt;DeviceObject,&amp;DosDeviceName);<br><br>    &#125;<br>    __finally<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != FileObject)<br>        &#123;<br>            ObDereferenceObject(FileObject);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != hFile)<br>        &#123;<br>            ZwClose(hFile);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != lpBuffer)<br>        &#123;<br>            ExFreePool(lpBuffer);<br>        &#125;<br><br>        KeUnstackDetachProcess(&amp;ApcState);<br><br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (NT_SUCCESS(nStatus))<br>    &#123;<br>        RtlInitUnicodeString(&amp;ProcessPath,FileName-&gt;FileName);<br><br>        <span class="hljs-keyword">if</span> (NT_SUCCESS(nDeviceStatus))<br>        &#123;<br>            RtlCopyUnicodeString(FullPath,&amp;DosDeviceName);<br>            RtlUnicodeStringCat(FullPath,&amp;ProcessPath);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            RtlCopyUnicodeString(FullPath,&amp;ProcessPath);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> nStatus;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据id获取进程全路径（2）"><a href="#根据id获取进程全路径（2）" class="headerlink" title="根据id获取进程全路径（2）"></a>根据id获取进程全路径（2）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 驱动入口函数总是在名为 “system”的进程中被执行，可以在 EPROCESS 中搜索这个字符串，一旦搜索到，记录下偏移位置</span><br><span class="hljs-comment">// 这个函数必须在DriverEntry中调用，否则cfCurProcName将不起作用。</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> s_cf_proc_name_offset = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cfCurProcNameInit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ULONG i;<br>PEPROCESS  curproc;<br>curproc = PsGetCurrentProcess();<br><span class="hljs-comment">// 搜索EPROCESS结构，在其中找到字符串</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>*<span class="hljs-number">4</span>*<span class="hljs-number">1024</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strncmp</span>(<span class="hljs-string">&quot;System&quot;</span>,(PCHAR)curproc+i,<span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;System&quot;</span>))) <br>&#123;<br>s_cf_proc_name_offset = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 以下函数可以获得进程名。返回获得的长度。</span><br><span class="hljs-function">ULONG <span class="hljs-title">cfCurProcName</span><span class="hljs-params">(PUNICODE_STRING name)</span></span><br><span class="hljs-function"></span>&#123;<br>PEPROCESS  curproc;<br>ULONGi,need_len;<br>    ANSI_STRING ansi_name;<br><span class="hljs-keyword">if</span>(s_cf_proc_name_offset == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 获得当前进程PEB,然后移动一个偏移得到进程名所在位置。</span><br>curproc = PsGetCurrentProcess();<br><br>    <span class="hljs-comment">// 这个名字是ansi字符串，现在转化为unicode字符串。</span><br>    RtlInitAnsiString(&amp;ansi_name,((PCHAR)curproc + s_cf_proc_name_offset));<br>    need_len = RtlAnsiStringToUnicodeSize(&amp;ansi_name);<br>    <span class="hljs-keyword">if</span>(need_len &gt; name-&gt;MaximumLength)<br>    &#123;<br>        <span class="hljs-keyword">return</span> RtlAnsiStringToUnicodeSize(&amp;ansi_name);<br>    &#125;<br>    RtlAnsiStringToUnicodeString(name,&amp;ansi_name,FALSE);<br><span class="hljs-keyword">return</span> need_len;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>windows驱动开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win64位寻址模式及获取随机PTE_BASE</title>
    <link href="/2021/04/01/win%20x64%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%E5%8F%8A%E8%8E%B7%E5%8F%96PTE_BASE/"/>
    <url>/2021/04/01/win%20x64%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%E5%8F%8A%E8%8E%B7%E5%8F%96PTE_BASE/</url>
    
    <content type="html"><![CDATA[<h3 id="windows-x64四级页表寻址模式及获取PTE-BASE基址"><a href="#windows-x64四级页表寻址模式及获取PTE-BASE基址" class="headerlink" title="windows x64四级页表寻址模式及获取PTE_BASE基址"></a>windows x64四级页表寻址模式及获取PTE_BASE基址</h3><h4 id="IA-32e-paging模式"><a href="#IA-32e-paging模式" class="headerlink" title="IA-32e paging模式"></a>IA-32e paging模式</h4><ul><li><p>  intel进入x64之后，将64位的寻址模式称为IA-32e paging模式，在AMD中称之为long-mode paging模式。</p></li><li><p>进入IA-32e paging模式所必须开启的位如下</p><ul><li>  IA32_EFER.LME=1：开启long-mode 模式</li><li>  CR0.PG=1, CR4.PAE=1：进入PAEpaging模式，并激活long-mode</li><li>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402161955.png" alt="图1-1"></li></ul></li><li><p>在32e模式下，一个64位的虚拟地址转换成真实的物理地址（使用4kb页）的过程如下</p><ul><li>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402161956.png" alt="图1-2"></li></ul></li><li><p>这里介绍一下32e paging模式下，使用的4级页表机制</p><ul><li>  PML4T:(Page Map Level 4 Table)：页转换表，每个表4k大小，包含512个 PML4TE 表项。</li><li>  PDPT:(Page Directory Poiner Table)：页目录指针表，每个表4k大小，包含512个 PDPTE 表项。</li><li>  PDT:(Page Directory Table)：页目录表，每个表4k大小，包含512个 PDTE 表项。</li><li>  PT:(Page Table)：页表，每个表4k大小，包含512个PTE表项。</li></ul></li><li><p>  IA32e 模式在 PAE的基础上新增了一级table，虚拟地址可以使用48位宽，在当前的x64模式中，处理器的线性地址空间只实现了48位，高16位  是bit47的符号扩展，全为0或者全为1。在intel中称之为 canonical address</p></li><li><p>每个表的表项都是8字节，虚拟地址结构由图1-2可知分为六部分，是16-9-9-9-9-12。</p><ul><li>  16：为bit47的符号扩展，目前保留</li><li>  9：每个表的表项索引</li><li>  12：表示这个地址具体于某个物理页的业内偏移</li></ul></li><li><p>IA32E 模式下的CR3</p><ul><li>  bit47-bit12 表示PML4T的物理地址</li><li>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402161957.png" alt="图1-3"></li></ul></li><li><p>IA32E 模式下的 PML4TE</p><ul><li>  bit12-bitM-1 是PDPT的物理地址</li><li>  bit63 是 xd位，表示当前页是否不可执行</li></ul></li><li><p>IA32E 模式下的 PDPTE</p><ul><li>  bit12-bitM-1 是PD的物理地址</li><li>  bit63 是 xd位，表示当前页是否不可执行</li></ul></li><li><p>IA32E 模式下的 PDE</p><ul><li>  bit12-bitM-1 是PT的物理地址</li><li>  bit63 是 xd位，表示当前页是否不可执行</li></ul></li><li><p>IA32E 模式下的 PTE</p><ul><li>  bit12-bitM-1 是当前要转换的虚拟页对应的物理页的物理地址</li></ul></li></ul><h4 id="win7-x64-虚拟地址转换例子"><a href="#win7-x64-虚拟地址转换例子" class="headerlink" title="win7 x64 虚拟地址转换例子"></a>win7 x64 虚拟地址转换例子</h4><ul><li><p> 首先，得到当前gdtr的虚拟地址是：<code>fffff80000b95000</code></p><p>   <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402161958.png" alt="image-20210402113406671"></p></li><li><p>经过拆分之后</p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-number">16</span>:<span class="hljs-number">1111111111111111</span><br>   <span class="hljs-number">9</span>:<span class="hljs-number">111110000</span><br><span class="hljs-number">9</span>:<span class="hljs-number">000000000</span><br>   <span class="hljs-number">9</span>:<span class="hljs-number">000000101</span><br>   <span class="hljs-number">9</span>:<span class="hljs-number">110010101</span><br>   <span class="hljs-number">12</span>:<span class="hljs-number">000000000000</span><br></code></pre></td></tr></table></figure></li><li><p>   得到cr3的物理地址</p></li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402161959.png" alt="image-20210402113612612"></p><ul><li>   得到PML4E的物理地址</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162000.png" alt="image-20210402113654887"></p><ul><li>   得到PDPTE的物理地址</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162001.png" alt="image-20210402113730170"></p><ul><li>   得到PDE的物理地址</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162002.png" alt="image-20210402113933571"></p><ul><li>   得到PTE的物理地址</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162003.png" alt="image-20210402114123104"></p><ul><li>   得到虚拟地址对应的物理页地址：b95000 再加上页内偏移0，得到物理地址对应的数据</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162004.png" alt="image-20210402114212227"></p><ul><li><p>与gdtr虚拟地址打印的数据进行对比，计算正确。<br>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162005.png" alt="image-20210402114310415"></p></li><li><p>   也可以使用<code>！vtop cr3 VirtualAddress</code>让windbg为我们做这个虚拟地址转换物理地址的过程</p></li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162006.png" alt="image-20210402141648021"></p><h4 id="获取win10的随机PTE-BASE"><a href="#获取win10的随机PTE-BASE" class="headerlink" title="获取win10的随机PTE_BASE"></a>获取win10的随机PTE_BASE</h4><ul><li><p>  首先提出一个问题，在写驱动代码的过程中，驱动如何去修改一个虚拟内存对应的PTE？因为我们之前做的实验使用的都是windbg的<code>!dq</code>命令，这个命令访问的是物理内存，那么驱动如何去读到这块物理内存呢？</p></li><li><p>  既然我们需要去读这块物理内存，操作系统在做内存管理的时候肯定要去修改PML4E,PDPTE,PDE,PTE的内容，那么操作系统是如何去更改这块内存的呢？答案就是，操作系统使用了页表自映射技术。</p></li><li><p>  操作系统在访问pte等表项的物理地址时肯定使用的是一个虚拟地址，而这个虚拟地址指向的就是pte所在的物理地址。在xp系统上，这个虚拟地址的起始是0xc0000000.在win7之后这个地址是FFFFF68000000000，并且在win10之后这个地址变的随机了。</p></li><li><p>在获取win10的随机的pte_base之前，我们先来看一下win7上可以访问各个P*E的虚拟地址</p><ul><li>  存储 PTE  的页面：FFFFF680`00000000</li><li>  存储 PDE 的页面：FFFFF6FB`40000000</li><li>  存储 PPE 的页面：FFFFF6FB`7DA00000</li><li>  存储 PXE 的页面：FFFFF6FB`7DBED000</li><li>对以上这些值，可以在windbg中使用<code>!pte 0</code>来得到。<ul><li>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162007.png" alt="image-20210402143933050"></li></ul></li><li>补充一下，intel 中描述的PML4E在windows称为PXE，PDPTE称为PPE</li></ul></li><li><p>实验：</p><ul><li>  查看地址0的pte<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162008.png" alt="image-20210402145917468"></li><li>  查看地址0x1000的pte<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162009.png" alt="image-20210402145924837"></li><li>  会发现，<strong>虚拟地址超过一页之后，当前虚拟地址pte所在的线性地址是</strong><code>((virtualaddr &amp; 0x0000ffffffffffff) &gt;&gt; 0xc) &lt;&lt; 3 + pte_base</code></li><li>验证一下我们做出的结论<ul><li>  查看gdtr虚拟地址<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162010.png" alt="image-20210402150223501"></li><li>  查看gdtr pte所在的虚拟地址<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162011.png" alt="image-20210402150301618"></li><li>  用我们的公式计算一下，结果正确<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162012.png" alt="image-20210402151424024"></li></ul></li></ul></li><li><p>上面的实验测试了如何用PTE_BASE计算出任何一个虚拟地址对应pte所在物理地址的线性地址。那么问题来了，如何得到这个PTE_BASE呢？获取基址的方法有很多，本文用的是特征码定位的方式。既然操作系统要使用到这个PTE_BASE，那么在内核文件中，肯定有使用这些值的地方，我们可以使用windbg的搜索命令，来搜搜在ntoskrnl模块中，有哪些地址上的值保存着PTE_BASE。</p><ul><li>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162013.png" alt="image-20210402152502816"></li><li>搜索之后，发现 ntoskrnl+0xcb3c 的地方存在着PTE_BASE，可以打开ida查看这个函数的反汇编，会发现，在原始的镜像文件中，这条汇编指令的操作数并不是这个值，可以想到，在操作系统启动过程中，在完成了PTE随机化之后，系统将这些硬编码在函数里面的值给修改了，这样之后就可以正常使用了。</li></ul></li><li><p>操作系统管理内存的时候肯定不只操作PTE，还有PDE,PPE,PXE，那么这些表的基址如何得到呢？我们先来看如何得到PDE的线性地址。</p><ul><li>  首先，PT肯定要占用一块物理内存，那么就肯定有一个PTE来指向PT所在的物理内存。我们在之前已经得到了如何计算一个虚拟地址所在的pte，那么我们计算出pte_base 这个虚拟地址所对应的pte就是pde_base了</li><li>实验：<ul><li>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402154852.png" alt="image-20210402154852249"></li></ul></li><li>知道以上这个逻辑之后，我们可以继续推理得到：<ul><li>指向PTE_BASE的PTE是PDE<ul><li>  验证：<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162014.png" alt="image-20210402155405359"></li></ul></li><li>指向PDE_BASE的PTE是PPE<ul><li>  验证：<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162015.png" alt="image-20210402155433912"></li></ul></li><li>指向PPE_BASE的PTE是PXE<ul><li>  验证：<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162016.png" alt="image-20210402155459243"></li></ul></li></ul></li></ul></li><li><p>我们来总结一下，到现在，我们已经能够得到一个任何一个虚拟地址的PTE，可以得到PTE_BASE,PDE_BASE,PPE_BASE,PXE_BASE。但是，操作系统管理内存的时候，要根据一个虚拟地址来修改这个虚拟地址对应的P*E，继续开始分析。</p><ul><li>  一个PTE所管理的页面大小是4KB的时候，虚拟地址每增加0x1000，PTE的值就会加八，我们可以回顾一下之前做的笔记</li><li>  0虚拟地址的PTE是：<strong>FFFFD58000000000</strong>，0x1000 虚拟地址对应的PTE是：<strong>FFFFD58000000008</strong></li><li>  正是因为这个原理，我们得出了计算任何一个虚拟地址所对应PTE虚拟地址的方法：<code>((virtualaddr &amp; 0x0000ffffffffffff) &gt;&gt; 0xc) &lt;&lt; 3 + pte_base</code>，这里的 右移12位就是除以了4kb，左移3位就是乘以8</li><li>PTE每个表项管理的是4kb，而PDE每个表项管理的是2MB，所以可以得出如下结论<ul><li>  任何一个虚拟地址所对应的PDE，用虚拟地址除以2mb，然后乘以8，再加上PDE_BASE，就可以得到这个虚拟地址对应的PDE了</li></ul></li><li>继续推理一下，可以得到<ul><li>  <code>pte_address = ((virtualAddress &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3 + PTE_BASE</code></li><li>  <code>pde_address = ((virtualAddress &amp; 0xffffffffffff) &gt;&gt; 21) &lt;&lt; 3 + PDE_BASE</code></li><li>  <code>ppe_address = ((virtualAddress &amp; 0xffffffffffff) &gt;&gt; 30) &lt;&lt; 3 + PPE_BASE</code></li><li>  <code>pxe_address = ((virtualAddress &amp; 0xffffffffffff) &gt;&gt; 39) &lt;&lt; 3 + PXE_BASE</code></li></ul></li></ul></li><li><p>代码验证：</p><ul><li><p>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162017.png" alt="image-20210402161526009"></p></li><li><pre><code class="c">  #include &lt;wdm.h&gt;    ULONG64 g_NtBase = 0xfffff80443aa7000;  ULONG64 g_PTEBase;  ULONG64 g_PDEBase;  ULONG64 g_PPEBase;  ULONG64 g_PXEBase;    ULONG64   GetPteAddress(      __in ULONG64 VirtualAddress) &#123;      return (((VirtualAddress &amp; 0xffffffffffff) &gt;&gt; 12) &lt;&lt; 3) + g_PTEBase;  &#125;    ULONG64  GetPdeAddress(      __in ULONG64 VirtualAddress) &#123;      return( ((VirtualAddress &amp; 0xffffffffffff) &gt;&gt; 21) &lt;&lt; 3) + g_PDEBase;  &#125;    ULONG64  GetPpeAddress(      __in ULONG64 VirtualAddress) &#123;      return (((VirtualAddress &amp; 0xffffffffffff) &gt;&gt; 30) &lt;&lt; 3) + g_PPEBase;    &#125;    ULONG64  GetPxeAddress(      __in ULONG64 VirtualAddress) &#123;      return (((VirtualAddress &amp; 0xffffffffffff) &gt;&gt; 39) &lt;&lt; 3) + g_PXEBase;  &#125;    NTSTATUS  DriverEntry(      __in PDRIVER_OBJECT pDriver,      __in PUNICODE_STRING pRegPath) &#123;      UNREFERENCED_PARAMETER(pDriver);      UNREFERENCED_PARAMETER(pRegPath);        KdPrint((&quot;Driver loaded....\n&quot;));        g_PTEBase = *( PULONG64 )(g_NtBase + 0xcb3c);      g_PDEBase = GetPteAddress(g_PTEBase);      g_PPEBase = GetPteAddress(g_PDEBase);      g_PXEBase = GetPteAddress(g_PPEBase);        KdPrint((&quot;PXE: %p\n&quot;, GetPxeAddress(0xfffff80446271fb0)));      KdPrint((&quot;PPE: %p\n&quot;, GetPpeAddress(0xfffff80446271fb0)));      KdPrint((&quot;PDE: %p\n&quot;, GetPdeAddress(0xfffff80446271fb0)));      KdPrint((&quot;PTE: %p\n&quot;, GetPteAddress(0xfffff80446271fb0)));        return STATUS_UNSUCCESSFUL;  &#125;</code></pre></li></ul></li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li>  <a href="https://blog.51cto.com/shayi1983/1734822">https://blog.51cto.com/shayi1983/1734822</a></li><li>  <a href="https://bbs.pediy.com/thread-254276-2.htm">https://bbs.pediy.com/thread-254276-2.htm</a></li><li>  <a href="https://www.bilibili.com/video/BV1yJ411T7dz">https://www.bilibili.com/video/BV1yJ411T7dz</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>windows内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对PatchGuard的一点研究</title>
    <link href="/2021/03/31/%E5%AF%B9PatchGuard%E7%9A%84%E4%B8%80%E7%82%B9%E7%A0%94%E7%A9%B6/"/>
    <url>/2021/03/31/%E5%AF%B9PatchGuard%E7%9A%84%E4%B8%80%E7%82%B9%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        PatchGuard 是微软公司为windows操作系统对从xp开始的64位操作系统引入的KPP（kernel Patch Protection）机制的一部分，主要目的是保护内核的一些关键数据结构免被第三方驱动修改。它通过定期检查这些关键的数据结构有没有被修改，如果检测到修改，那么windows将会引发一个错误编号为0x109的BSOD，错误代码是 CRITICAL_STRUCTURE_CORRUPTION ，禁止修改的这些关键数据结构在微软官方文档中列出部分。同时，在windbg中使用命令<code> !analyze -show 109</code>同样可以列出一份保护列表。</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162329.png" alt="PatchGuard保护的数据结构"></p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402162330.png" alt="windbg列出保护列表"></p><h3 id="PG工作方式"><a href="#PG工作方式" class="headerlink" title="PG工作方式"></a>PG工作方式</h3><ul><li>大部分PG检测基于context结构体，内容包括<ul><li>一小段自解密代码（ntoskrnl名称为CmpAppendDllSection，这个名字是为了混淆）<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210406112340.png" alt="CmpAppendDllSection 函数代码">  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210406112341.png" alt="执行中的context的rcx是rip"></li><li>要用到的系统api指针</li><li>重要的api代码备份（例如KiBugCheckEx）</li><li>INITKDBG 节的备份</li><li>  要检测的目标地址，大小，checksum 构成的结构体数组</li></ul></li><li>  context 大部分时间是处于加密状态，在context执行过程中，由头部进行自解密，如上图所示，context执行时，rcx指向当前rip+4</li><li>  context 是在系统初始化时候进行初始化，此时所有数据都是没被修改的</li><li>  context 的地址作为系统系统，dpc ，timer等的参数，随着调度被传递</li><li>  context 验证逻辑周期约为2min，每次检测的目标块随机。</li><li>context 采用接力的方式进行调度<ul><li>  自解密 -&gt; 检测逻辑 -&gt; 复制自身到新的context -&gt; 加密新的context -&gt; 销毁旧的context</li></ul></li><li>  context 检测逻辑的调用源具有随机性，在PG初始化时候决定</li></ul><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><ul><li>静态补丁攻击：攻击pg初始化<ul><li>  优点：一次补丁，终身可用。</li><li>  缺点：需要重启，不是动态pass</li></ul></li><li>VT<ul><li>  利用vt使PatchGuard保护的数据读写分离</li><li>  重载一份新内核，修改msr寄存器的入口点。利用vt隐藏修改的寄存器</li></ul></li><li>定位所有context的调用源头，对源头进行patch<ul><li>  源头太多太多，很难全部找到</li></ul></li><li>攻击context：修改 context逻辑<ul><li>  搜索内存，初筛context</li><li>  基于加密算法特征，定位context</li><li>  解密context，修改context逻辑，加密写会context</li></ul></li><li>攻击context：接管页面异常<ul><li>  搜索内存，初筛context，设置不可执行</li><li>  hook pagefault 接管执行保护异常</li><li>   判断是否是context调用，修改context代码直接返回</li></ul></li><li>攻击 DPC 调用<ul><li>  在KiRetireDpcList处保存context，如果发生109蓝屏，直接恢复保存的环境（老v时光倒流大法）</li></ul></li></ul><h3 id="实验：win7（攻击context代码）"><a href="#实验：win7（攻击context代码）" class="headerlink" title="实验：win7（攻击context代码）"></a>实验：win7（攻击context代码）</h3><p>​        win7的pg执行点是CmpAppendDllSection函数的备份，这份代码在运行时会进行自解密，以rdx为key，解密代码。</p><p>这里的解密算法有一个破绽，假设</p><p>CmpAppendDllSection+0x0的密文内容为A，大小8字节；</p><p>CmpAppendDllSection+0x0的明文内容为B，大小8字节；</p><p>CmpAppendDllSection+0x8的密文内容为C，大小8字节；</p><p>CmpAppendDllSection+0x8的明文内容为D，大小8字节；</p><p>它们因为都是经过key解密出来的，所以有一个这样的关系：A ^ B == C ^ D。</p><p>我们遍历可能的context时，为了判断是否是pg的context就可以使用这样的方式。读出内容，然后使A ^ B == C ^ D 表达式成立，成立之后，就可以得到key的值，从而解密出整个context，修改完成之后再加密回去。这是这种方法的主要逻辑。</p><ul><li><p>扫描可能context</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestroyPatchGuardByPool</span><span class="hljs-params">(PATCH_GUARG_CONTEXT *pPatchGuardContext)</span></span><br><span class="hljs-function"></span>&#123;<br>ULONG_PTRIndex;<br>ULONG_PTRStartAddress;<br><br>POOL_TRACKER_BIG_PAGESPoolTrackerBigPagesItem;<br><br><span class="hljs-keyword">for</span> (Index = <span class="hljs-number">0</span>; Index &lt; *(ULONG_PTR*)pPatchGuardContext-&gt;lpkvPoolBigPageTableSize; Index++)<br>&#123;<br>PoolTrackerBigPagesItem = pPatchGuardContext-&gt;lpkvPoolBigPageTable[Index];<br>StartAddress = (ULONG_PTR)PoolTrackerBigPagesItem.Va;<br><br><span class="hljs-keyword">if</span> (StartAddress == <span class="hljs-number">0</span> || (StartAddress &amp; <span class="hljs-number">0x1</span>) != <span class="hljs-number">0</span>)<span class="hljs-comment">//为0或1代表未使用</span><br>&#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-comment">//我们只扫描非换页内存池的</span><br><span class="hljs-keyword">if</span> (StartAddress &lt; *(ULONG_PTR*)pPatchGuardContext-&gt;lpkvMiNonPagedPoolStartAligned)<br>&#123;<br><span class="hljs-comment">//非换页内存池</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br>AttackPatchGuard((PUCHAR)StartAddress, (ULONG)PoolTrackerBigPagesItem.NumberOfBytes);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>  攻击 context（1）</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">BOOLEAN <span class="hljs-title">AttackPatchGuard</span><span class="hljs-params">(PUCHAR MemStart, ULONG MemSize)</span></span><br><span class="hljs-function"></span>&#123;<br>ULONG_PTR Key = <span class="hljs-number">0</span>;<br>ULONG_PTR Count;<br>ULONG_PTR SearchStart = (ULONG_PTR)MemStart;<br><br><span class="hljs-comment">//因为下面的搜索最少要求memSize大于0x98，所以我们要在这里判断一下</span><br><span class="hljs-keyword">if</span> (MemSize &lt; <span class="hljs-number">0x100</span>)<span class="hljs-comment">//判断大点儿</span><br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (MmIsAddressValid(MemStart) == FALSE || MmIsAddressValid(MemStart + MemSize - <span class="hljs-keyword">sizeof</span>(ULONG_PTR)) == FALSE)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br><span class="hljs-keyword">for</span> (Count = <span class="hljs-number">0</span>; Count &lt; MemSize; Count++)<br>&#123;<br><br><span class="hljs-comment">//下面是对明文context的处理</span><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">141</span> + <span class="hljs-number">22</span>) &lt; MemSize &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)(SearchStart + Count + <span class="hljs-number">141</span>), <span class="hljs-string">&quot;\x48\x31\x84\xCA\xC0\x00\x00\x00\x48\xD3\xC8\xE2\xF3\x8B\x82\x88\x02\x00\x00\x48\x03\xC2&quot;</span>, <span class="hljs-number">22</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;CmpAppendDllSection address:%p&quot;</span>, SearchStart + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;CmpAppendDllSection address content:%p&quot;</span>, *(ULONG_PTR*)(SearchStart + Count));<br><span class="hljs-built_in">memcpy</span>((PUCHAR)SearchStart + Count + <span class="hljs-number">0x8</span>, <span class="hljs-string">&quot;\xC3\x90\x90\x90&quot;</span>, <span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">26</span> + <span class="hljs-number">20</span>) &lt; MemSize &amp;&amp;\<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)(SearchStart + Count + <span class="hljs-number">26</span>), <span class="hljs-string">&quot;\x41\x57\x48\x81\xEC\x50\x06\x00\x00\x48\x8D\xA8\x58\xFA\xFF\xFF\x48\x83\xE5\x80&quot;</span>, <span class="hljs-number">20</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;FsRtlMdlReadCompleteDevEx address:%p&quot;</span>, SearchStart + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;FsRtlMdlReadCompleteDevEx address content:%p&quot;</span>, *(ULONG_PTR*)(SearchStart + Count));<br>*(ULONG32*)(SearchStart + Count) = <span class="hljs-number">0xC3C03148</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">15</span> + <span class="hljs-number">26</span>) &lt; MemSize &amp;&amp;\<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)(SearchStart + Count + <span class="hljs-number">15</span>), <span class="hljs-string">&quot;\x8B\x82\x88\x02\x00\x00\x48\x03\xC2\x48\x83\xEC\x28\xFF\xD0\x48\x83\xC4\x28\x4C\x8B\x80\xE8\x00\x00\x00&quot;</span>, <span class="hljs-number">26</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//因为RtlLookupFunctionEntryEx这句lea     rdx, [rcx-1000h]变动的，无法定位，而利用其它的特征码又和CmpAppendDllSection相同了，所以这里我们判断一下头8个字节的特征</span><br><span class="hljs-keyword">if</span> (*(ULONG_PTR*)(SearchStart + Count) == <span class="hljs-number">0x085131481131482E</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;RtlLookupFunctionEntryEx address:%p&quot;</span>, SearchStart + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;RtlLookupFunctionEntryEx address content:%p&quot;</span>, *(ULONG_PTR*)(SearchStart + Count + <span class="hljs-number">0xF</span> - <span class="hljs-number">0x8</span>));<br><span class="hljs-built_in">memcpy</span>((PUCHAR)SearchStart + Count + <span class="hljs-number">8</span>, <span class="hljs-string">&quot;\xC3\x90\x90\x90\x90\x90\x90&quot;</span>, <span class="hljs-number">7</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">15</span> + <span class="hljs-number">14</span>) &lt; MemSize &amp;&amp;\<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)(SearchStart + Count + <span class="hljs-number">15</span>), <span class="hljs-string">&quot;\x33\xC0\x49\x89\x02\x49\x83\xEA\x08\x4C\x3B\xD4\x73\xF4&quot;</span>, <span class="hljs-number">14</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;SdbpCheckDll address:%p&quot;</span>, SearchStart + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;SdbpCheckDll address content:%p&quot;</span>, *(ULONG_PTR*)(SearchStart + Count));<br>*(UCHAR*)(SearchStart + Count) = <span class="hljs-number">0xC3</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">2</span> + <span class="hljs-number">15</span>) &lt; MemSize &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)(SearchStart + Count + <span class="hljs-number">2</span>), <span class="hljs-string">&quot;\x9C\x48\x83\xEC\x20\x8B\x44\x24\x20\x45\x33\xC9\x45\x33\xC0&quot;</span>, <span class="hljs-number">15</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;KiTimerDispatch address:%p&quot;</span>, SearchStart + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;KiTimerDispatch address content:%p&quot;</span>, *(ULONG_PTR*)(SearchStart + Count));<br><span class="hljs-built_in">memcpy</span>((PUCHAR)SearchStart + Count + <span class="hljs-number">3</span>, <span class="hljs-string">&quot;\x59\xC3&quot;</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//pop rcx  retn</span><br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">42</span> + <span class="hljs-number">24</span>) &lt; MemSize &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)(SearchStart + Count + <span class="hljs-number">42</span>), <span class="hljs-string">&quot;\x48\x8B\xDA\xBA\x26\x00\x00\x00\x41\xB8\x30\x01\x00\x00\x48\x8D\x85\x80\x00\x00\x00\x45\x33\xFF&quot;</span>, <span class="hljs-number">24</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;sub_1401A2010 address:%p&quot;</span>, SearchStart + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;sub_1401A2010 address content:%p&quot;</span>, *(ULONG_PTR*)(SearchStart + Count));<br>&#125;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">//下面是对密文context的处理</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">INIT:000000014057224Bloc_14057224B:                          ; CODE XREF: CmpAppendDllSection+98j</span><br><span class="hljs-comment">INIT:000000014057224B 48 31 84 CA C0 00 00 00xor     [rdx+rcx*8+0C0h], rax</span><br><span class="hljs-comment">INIT:0000000140572253 48 D3 C8ror     rax, cl</span><br><span class="hljs-comment">INIT:0000000140572256 E2 F3loop    loc_14057224B</span><br><span class="hljs-comment">INIT:0000000140572258 8B 82 88 02 00 00mov     eax, [rdx+288h]</span><br><span class="hljs-comment">INIT:000000014057225E 48 03 C2add     rax, rdx</span><br><span class="hljs-comment">INIT:0000000140572261 48 83 EC 28sub     rsp, 28h</span><br><span class="hljs-comment">INIT:0000000140572265 FF D0call    rax</span><br><span class="hljs-comment">INIT:0000000140572267 48 83 C4 28add     rsp, 28h</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">0xc0</span> + <span class="hljs-number">0x8</span>) &lt; MemSize)<br>&#123;<br>Key = *(ULONG_PTR*)(SearchStart + Count + <span class="hljs-number">0x8D</span>) ^ <span class="hljs-number">0x000000C0CA843148</span>;<br><span class="hljs-keyword">if</span> (Key != <span class="hljs-number">0</span> &amp;&amp; (*(ULONG_PTR*)(SearchStart + Count + <span class="hljs-number">0x8D</span> + <span class="hljs-number">0x08</span>) ^ <span class="hljs-number">0x88828BF3E2C8D348</span>) == Key &amp;&amp;<br>(*(ULONG_PTR*)(SearchStart + Count + <span class="hljs-number">0x8D</span> + <span class="hljs-number">0x10</span>) ^ <span class="hljs-number">0x8348C20348000002</span>) == Key &amp;&amp;<br>(*(ULONG_PTR*)(SearchStart + Count + <span class="hljs-number">0x8D</span> + <span class="hljs-number">0x18</span>) ^ <span class="hljs-number">0x28C48348D0FF28EC</span>) == Key)<br>&#123;<br>ULONG_PTRContextSize;<br>ULONG_PTRContextKey;<br><br><span class="hljs-comment">//ContextKey是解密出来的context key</span><br>ContextKey = (*(ULONG_PTR*)(SearchStart + Count + <span class="hljs-number">0x8</span>)) ^ <span class="hljs-number">0x1851314810513148</span>;<br>ContextSize = ((*(ULONG_PTR*)(SearchStart + Count + <span class="hljs-number">0xc0</span>)) ^ ContextKey) &gt;&gt; <span class="hljs-number">32</span>;<span class="hljs-comment">//context+0xc4是保存从+0xc8偏移context后面整个加密长度,注意只有4字节</span><br><br><span class="hljs-comment">//判断一下长度是否越界</span><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">0xc8</span> + ContextSize * <span class="hljs-number">0x8</span>) &lt;= MemSize)<br>&#123;<br><span class="hljs-comment">//找到了，我们进行处理pg的行为吧</span><br>DynamicAttackPatchguardEncryptCode((PUCHAR)SearchStart + Count, <span class="hljs-number">0xc8</span> + ContextSize * <span class="hljs-number">0x8</span>, ContextKey);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  攻击 context（2）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DynamicAttackPatchguardEncryptCode</span><span class="hljs-params">(PUCHAR Context, ULONG_PTR Size, ULONG_PTR Key)</span></span><br><span class="hljs-function"></span>&#123;<br>ULONG_PTRCount, Index;<br>PULONG_PTRlpDecryptMem;<br>ULONG_PTRContextKey;<br>ULONG_PTRDecryptSize;<br>UCHARRorBit;<br><br>ContextKey = Key;<br><br><span class="hljs-comment">//申请一块内存，用来解密的！</span><br>lpDecryptMem = (PULONG_PTR)ExAllocatePool(NonPagedPool, Size);<br>RtlCopyMemory(lpDecryptMem, Context, Size);<br><br><span class="hljs-comment">//首先解密出context头部的CmpAppendDllSection解密函数</span><br><span class="hljs-keyword">for</span> (Count = <span class="hljs-number">0</span>; Count &lt; <span class="hljs-number">0xc8</span> / <span class="hljs-keyword">sizeof</span>(ULONG_PTR); Count++)<br>&#123;<br>lpDecryptMem[Count] ^= ContextKey;<br>&#125;<br><br><span class="hljs-comment">//算出解密长度</span><br>DecryptSize = lpDecryptMem[<span class="hljs-number">0xc0</span> / <span class="hljs-keyword">sizeof</span>(ULONG_PTR)] &gt;&gt; <span class="hljs-number">32</span>;<br>Index = DecryptSize;<br><br><span class="hljs-comment">//然后解密出剩下的部分</span><br><span class="hljs-keyword">do</span><br>&#123;<br>lpDecryptMem[(<span class="hljs-number">0xc8</span> / <span class="hljs-keyword">sizeof</span>(ULONG_PTR) - <span class="hljs-number">1</span>) + Index] ^= ContextKey;<br>RorBit = (UCHAR)Index;<br>ContextKey = _rotr64(ContextKey, RorBit);<br>&#125; <span class="hljs-keyword">while</span> (--Index);<br><br><span class="hljs-comment">//解密完成~~</span><br><span class="hljs-keyword">for</span> (Count = <span class="hljs-number">0</span>; Count &lt; Size; Count++)<br>&#123;<br><span class="hljs-comment">//下面是对明文context的处理</span><br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">141</span> + <span class="hljs-number">22</span>) &lt; Size &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)((ULONG_PTR)lpDecryptMem + Count + <span class="hljs-number">141</span>), <span class="hljs-string">&quot;\x48\x31\x84\xCA\xC0\x00\x00\x00\x48\xD3\xC8\xE2\xF3\x8B\x82\x88\x02\x00\x00\x48\x03\xC2&quot;</span>, <span class="hljs-number">22</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;--CmpAppendDllSection address:%p&quot;</span>, (ULONG_PTR)lpDecryptMem + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;--CmpAppendDllSection address content:%p&quot;</span>, *(ULONG_PTR*)((ULONG_PTR)lpDecryptMem + Count));<br><span class="hljs-built_in">memcpy</span>((PUCHAR)lpDecryptMem + Count + <span class="hljs-number">0x8</span>, <span class="hljs-string">&quot;\xC3\x90\x90\x90&quot;</span>, <span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">26</span> + <span class="hljs-number">20</span>) &lt; Size &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)((ULONG_PTR)lpDecryptMem + Count + <span class="hljs-number">26</span>), <span class="hljs-string">&quot;\x41\x57\x48\x81\xEC\x50\x06\x00\x00\x48\x8D\xA8\x58\xFA\xFF\xFF\x48\x83\xE5\x80&quot;</span>, <span class="hljs-number">20</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;--FsRtlMdlReadCompleteDevEx address:%p&quot;</span>, (ULONG_PTR)lpDecryptMem + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;--FsRtlMdlReadCompleteDevEx address content:%p&quot;</span>, *(ULONG_PTR*)((ULONG_PTR)lpDecryptMem + Count));<br> <span class="hljs-comment">//xor rax,rax</span><br> <span class="hljs-comment">//retn</span><br>*(ULONG32*)((ULONG_PTR)lpDecryptMem + Count) = <span class="hljs-number">0xC3C03148</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">15</span> + <span class="hljs-number">26</span>) &lt; Size &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)((ULONG_PTR)lpDecryptMem + Count + <span class="hljs-number">15</span>), <span class="hljs-string">&quot;\x8B\x82\x88\x02\x00\x00\x48\x03\xC2\x48\x83\xEC\x28\xFF\xD0\x48\x83\xC4\x28\x4C\x8B\x80\xE8\x00\x00\x00&quot;</span>, <span class="hljs-number">26</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//因为RtlLookupFunctionEntryEx这句lea     rdx, [rcx-1000h]变动的，无法定位，而利用其它的特征码又和CmpAppendDllSection相同了，所以这里我们判断一下头8个字节的特征</span><br><span class="hljs-keyword">if</span> (*(ULONG_PTR*)((ULONG_PTR)lpDecryptMem + Count) == <span class="hljs-number">0x085131481131482E</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;--RtlLookupFunctionEntryEx address:%p&quot;</span>, (ULONG_PTR)lpDecryptMem + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;--RtlLookupFunctionEntryEx address content:%p&quot;</span>, *(ULONG_PTR*)((ULONG_PTR)lpDecryptMem + Count + <span class="hljs-number">0xF</span> - <span class="hljs-number">0x8</span>));<br><span class="hljs-built_in">memcpy</span>((PUCHAR)lpDecryptMem + Count + <span class="hljs-number">8</span>, <span class="hljs-string">&quot;\xC3\x90\x90\x90\x90\x90\x90&quot;</span>, <span class="hljs-number">7</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">15</span> + <span class="hljs-number">14</span>) &lt; Size &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)((ULONG_PTR)lpDecryptMem + Count + <span class="hljs-number">15</span>), <span class="hljs-string">&quot;\x33\xC0\x49\x89\x02\x49\x83\xEA\x08\x4C\x3B\xD4\x73\xF4&quot;</span>, <span class="hljs-number">14</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;--SdbpCheckDll address:%p&quot;</span>, (ULONG_PTR)lpDecryptMem + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;--SdbpCheckDll address content:%p&quot;</span>, *(ULONG_PTR*)((ULONG_PTR)lpDecryptMem + Count));<br>*(UCHAR*)((ULONG_PTR)lpDecryptMem + Count) = <span class="hljs-number">0xC3</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">2</span> + <span class="hljs-number">15</span>) &lt; Size &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)((ULONG_PTR)lpDecryptMem + Count + <span class="hljs-number">2</span>), <span class="hljs-string">&quot;\x9C\x48\x83\xEC\x20\x8B\x44\x24\x20\x45\x33\xC9\x45\x33\xC0&quot;</span>, <span class="hljs-number">15</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;--KiTimerDispatch address:%p&quot;</span>, (ULONG_PTR)lpDecryptMem + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;--KiTimerDispatch address content:%p&quot;</span>, *(ULONG_PTR*)((ULONG_PTR)lpDecryptMem + Count));<br><span class="hljs-built_in">memcpy</span>((PUCHAR)lpDecryptMem + Count + <span class="hljs-number">3</span>, <span class="hljs-string">&quot;\x59\xC3&quot;</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//pop rcx  retn</span><br>&#125;<br><br><span class="hljs-keyword">if</span> ((Count + <span class="hljs-number">42</span> + <span class="hljs-number">24</span>) &lt; Size &amp;&amp; \<br><span class="hljs-built_in">memcmp</span>((<span class="hljs-keyword">void</span>*)((ULONG_PTR)lpDecryptMem + Count + <span class="hljs-number">42</span>), <span class="hljs-string">&quot;\x48\x8B\xDA\xBA\x26\x00\x00\x00\x41\xB8\x30\x01\x00\x00\x48\x8D\x85\x80\x00\x00\x00\x45\x33\xFF&quot;</span>, <span class="hljs-number">24</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>LOG_DEBUG(<span class="hljs-string">&quot;--sub_1401A2010 address:%p&quot;</span>, (ULONG_PTR)lpDecryptMem + Count);<br>LOG_DEBUG(<span class="hljs-string">&quot;--sub_1401A2010 address content:%p&quot;</span>, *(ULONG_PTR*)((ULONG_PTR)lpDecryptMem + Count));<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//加密回去</span><br><span class="hljs-keyword">for</span> (Count = <span class="hljs-number">0</span>; Count &lt; <span class="hljs-number">0xc8</span> / <span class="hljs-keyword">sizeof</span>(ULONG_PTR); Count++)<br>&#123;<br>lpDecryptMem[Count] ^= ContextKey;<br>&#125;<br><br>Index = DecryptSize;<br><br><span class="hljs-comment">//然后加密出剩下的部分</span><br><span class="hljs-keyword">do</span><br>&#123;<br>lpDecryptMem[(<span class="hljs-number">0xc8</span> / <span class="hljs-keyword">sizeof</span>(ULONG_PTR) - <span class="hljs-number">1</span>) + Index] ^= ContextKey;<br>RorBit = (UCHAR)Index;<br>ContextKey = _rotr64(ContextKey, RorBit);<br>&#125; <span class="hljs-keyword">while</span> (--Index);<br><br><span class="hljs-comment">//copy回去</span><br>RtlCopyMemory(Context, lpDecryptMem, Size);<br><br>ExFreePool(lpDecryptMem);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实验：win10（hook-页错误处理）"><a href="#实验：win10（hook-页错误处理）" class="headerlink" title="实验：win10（hook 页错误处理）"></a>实验：win10（hook 页错误处理）</h3><p>win10之后，微软对context的加密算法进行了升级，攻击context变得困难（shark牛逼，飞总牛逼），所以这次我们来用一下hook fault的方法。</p><ul><li>  扫描可能context，设置不可执行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c">status = ZwQuerySystemInformation(<span class="hljs-number">0x42</span>, g_BigPoolInfo, retLength + <span class="hljs-number">0x1000</span>, &amp;retLength);<br><br><span class="hljs-keyword">if</span> ( status != STATUS_SUCCESS ) &#123;<br>KdPrint((<span class="hljs-string">&quot;[Pg_test] : ZwQuerySystemInformation - query error: %p\n&quot;</span>), status);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>KdPrint((<span class="hljs-string">&quot;[Pg_test] : g_BigPoolInfo %p \n&quot;</span>, g_BigPoolInfo));<br>KdPrint((<span class="hljs-string">&quot;[Pg_test] : pool count is %ud \n&quot;</span>, g_BigPoolInfo-&gt;count));<br><span class="hljs-keyword">for</span> (ULONG i = <span class="hljs-number">0</span>; i &lt; g_BigPoolInfo-&gt;count; i++) &#123;<br><span class="hljs-comment">// size &gt; context_size(xx)</span><br><span class="hljs-keyword">if</span> (g_BigPoolInfo-&gt;AllocatedInfo[i].SizeInBytes &gt; <span class="hljs-number">0x8000</span>)&#123;<br>PVOID context_addr = g_BigPoolInfo-&gt;AllocatedInfo[i].VirtualAddress;<br>PULONG64 ppte = GetPteAddress(context_addr);<br>ULONG64 pte = *( PULONG64 )ppte;<br>ULONG64 ppde = GetPdeAddress(context_addr);<br>ULONG64 pde = *( PULONG64 )ppde;<br><br><span class="hljs-comment">// not large page</span><br><span class="hljs-keyword">if</span> ( !(pde &amp; <span class="hljs-number">0x80</span>) ) &#123;<br><span class="hljs-keyword">if</span> ( (pte &amp; <span class="hljs-number">0x8000000000000000</span>) == <span class="hljs-number">0</span> &amp;&amp; (pte &amp; <span class="hljs-number">1</span>) ) &#123;<br>pte |= <span class="hljs-number">0x8000000000000000</span>;<br><span class="hljs-comment">// context can not excute, so ... pagefault..</span><br>*ppte = pte;<br>KdPrint((<span class="hljs-string">&quot;[Pg_test] : contextAddr: %p, size: %p, pte: %p\n&quot;</span>, context_addr, g_BigPoolInfo-&gt;AllocatedInfo[i].SizeInBytes, pte));<br>contextNum++;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>KdPrint((<span class="hljs-string">&quot;[Pg_test] :context count : %d\n&quot;</span>), contextNum);<br></code></pre></td></tr></table></figure><ul><li>hook pagefaut<ul><li>  判断是否是context的特征，是就返回，不是就跳转到原先的异常处理</li><li>  这里hook时候要注意，win10 1809（不确定）系统有影子页表，不要hook shadow 处理，更新好了cr3之后再去hook，也就是真正的页错误处理</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs asm">Asm_hook_PageFaultProc<br><br><br>        push rcx<br><br>        mov rax, [rsp + 10h]      ;error code<br>        cmp rax, 11h<br>        jnz @back<br><br><br>        mov rax, [rsp + 18h]    ;addr<br>        mov eax, dword ptr [rax]<br>        cmp eax, 1131482eh<br>        jnz @back<br><br>    ; 这里是为了记录pg的context，方便查找调用源<br>        mov [DebugData + 30h], rdx<br>;----------------------------------------<br>        mov rax, [DebugData+10h]<br>        inc rax<br>        mov [DebugData+10h], rax<br>        mov [DebugData+18h], rcx<br><br>        mov rax, [rsp + 18h]    ;addr<br>        mov [DebugData+20h], rax<br><br>; 这里是直接返回到context的调用源，不是修改context的汇编为ret<br>        mov rax, [rsp+28h]  ;efl<br>        push rax<br>        popfq<br>        mov rax, [rsp+38h]  ;ss<br>        mov ss, ax<br>        mov rax, [rsp+30h]  ;rsp<br>        mov [DebugData+40h], rax<br>        mov rsp, rax<br><br>        ret<br>;-----------------------------------------<br><br>@back:<br>        pop rcx<br>        pop rax<br>        push rbp<br>        sub rsp, 158h<br>        lea rbp, [rsp+80h]<br>        sub rsp, 8<br>        mov dword ptr [rsp], (NT_BASE+ 1CA450h)and 0ffffffffh<br>        mov dword ptr [rsp+4], NT_BASE shr 32<br>        ret<br>Asm_hook_PageFault Endp<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/bug-check-0x109---critical-structure-corruption">Bug 检查 0x109 CRITICAL_STRUCTURE_CORRUPTION - Windows drivers | Microsoft Docs</a></li><li>  <a href="https://github.com/killvxk/DisableWin10PatchguardPoc">https://github.com/killvxk/DisableWin10PatchguardPoc</a></li><li>  <a href="https://github.com/tandasat/PgResarch">https://github.com/tandasat/PgResarch</a></li><li>  <a href="https://bbs.pediy.com/thread-148451.htm">https://bbs.pediy.com/thread-148451.htm</a></li><li>  <a href="https://github.com/zzhouhe/PG1903/blob/master/amd64/x64asm.asm">https://github.com/zzhouhe/PG1903/blob/master/amd64/x64asm.asm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows内核</category>
      
      <category>逆向</category>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows内核</tag>
      
      <tag>逆向</tag>
      
      <tag>PatchGuard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入解析irq与irql：从pic到apic</title>
    <link href="/2021/03/25/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90irq%E4%B8%8Eirql%EF%BC%9A%E4%BB%8Epic%E5%88%B0apic/"/>
    <url>/2021/03/25/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90irq%E4%B8%8Eirql%EF%BC%9A%E4%BB%8Epic%E5%88%B0apic/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        一直看文档说DPC及以上级别不能访问非分页内存，对于我来说，看到这句话，总想问一个为什么？研究了一下之后，在《windows内核原理与实现》中有如下解释<code>在DISPATCH_LEVEL或更高的 IRQL 上，不能访问换页内存区，因为一旦发生换页动作，就需要执行 I/O 操作，从磁盘上读入页面，期间至少有一个等待动作。因此，在中断处理例程中，只能访问非换页内存。</code>这使我又产生了另一个疑问：操作系统是如何让高等级的irql可以打断低等级irql的执行的？经过查询了大量资料之后，为了防止忘记，遂写本文方便日后查询。</p><h3 id="几个名词"><a href="#几个名词" class="headerlink" title="几个名词"></a>几个名词</h3><p><strong>IRQL</strong>：中断请求优先级，是由 windows 虚拟出来的概念。优先级主要有以下几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Interrupt Request Level definitions</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PASSIVE_LEVEL 0             <span class="hljs-comment">// Passive release level</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOW_LEVEL 0                 <span class="hljs-comment">// Lowest interrupt level</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> APC_LEVEL 1                 <span class="hljs-comment">// APC interrupt level</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DISPATCH_LEVEL 2            <span class="hljs-comment">// Dispatcher level</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CMCI_LEVEL 5                <span class="hljs-comment">// CMCI handler level</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PROFILE_LEVEL 27            <span class="hljs-comment">// timer used for profiling.</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLOCK1_LEVEL 28             <span class="hljs-comment">// Interval clock 1 level - Not used on x86</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLOCK2_LEVEL 28             <span class="hljs-comment">// Interval clock 2 level</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IPI_LEVEL 29                <span class="hljs-comment">// Interprocessor interrupt level</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> POWER_LEVEL 30              <span class="hljs-comment">// Power failure level</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HIGH_LEVEL 31               <span class="hljs-comment">// Highest interrupt level</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CLOCK_LEVEL                 (CLOCK2_LEVEL)</span><br></code></pre></td></tr></table></figure><p>​    在 Windows 中， 所有的用户线程都处于 PASSIVE_LEVEL 级别上运行，系统线程调度器在 DISPATCH_LEVEL 上运行，缺页异常处理在 APC_LEVEL 级别上运行。</p><p><strong>IRQ</strong> ：中断请求。当中断发生时，硬件会通过与中断控制器相连的信号线通知中断控制器有中断发生，此时中断控制器会向 CPU 报告中断，CPU 可用过 IRQ 编号来识别中断。</p><p><strong>Interrupt Vetor</strong>：中断向量号，即产生一个中断或异常时，cpu 使用这个号作为 IDT 表中的下标，来进行处理。</p><p><strong>PIC</strong> ：可编程中断控制器，是一块芯片，这块芯片包含中断请求寄存器，中断在寄存器，中断屏蔽寄存器等，它用来控制中断，以及决定报告给 cpu 的中断向量号。一般我们电脑里用的芯片都是8259A中断控制器，分为主从两块，一片有八个请求信号线，通过级联，可以支持 15个等级的IRQ。</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153357.png" alt="经典的8259A中断控制器"></p><p><strong>APIC</strong> ：高级可编程中断控制器，老旧的PIC在很久以前就被淘汰了，取而代之的是新的APIC，APIC主要应用于多处理器操作系统，是为了解决IRQ太少和处理器间中断而产生的。APIC的HAL和PIC的HAL有很大的不同，很突出的一个特点就是APIC的HAL不用再象PIC的HAL那样虚拟一个中断控制器，IRQL的概念已经可以通过中断向量的形式被APIC支持。事实上，因为被APIC所支持，所以在APIC HAL里IRQL的实现比PIC HAL那样虚拟一个中断控制器要简单得多了。</p><h3 id="PIC-的-IRQ-到-IRQL"><a href="#PIC-的-IRQ-到-IRQL" class="headerlink" title="PIC 的 IRQ 到 IRQL"></a>PIC 的 IRQ 到 IRQL</h3><p>​        我们知道当中断发生时，CPU 会用中断向量做索引，从 IDT 中找到对应的中断服务例程，那么中断向量是从哪里来的呢？这里就利用了中断控制器的可编程性来决定的了。它存储在8259A的中断向量寄存器中。Windows中，系统初始化的时候对PIC的编程为：指定主片的起始中断向量号为0x30，指定从片的起始中断向量号为0x38。这样，通过中断控制器连接的15个外设将被平坦的映射到IDT中0x30-0x40这一范围中。Windows内核启动初始化过程中使用了hal!HalpInitializePICs对8259a芯片进行编程。查看一下源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs asm">EnableInterrupts equ [esp + 0ch]<br><br>cPublicProc _HalpInitializePICs       ,1<br><br>        push    esi                             ; save caller&#39;s esi<br>        pushfd<br>        cli                                     ; disable interrupt<br><br>        lea     esi, PICsInitializationString<br>        lodsw                                   ; (AX) &#x3D; PIC port 0 address<br>Hip10:  movzx   edx, ax<br>        outsb                                   ; output ICW1<br>        IODelay<br>        inc     edx                             ; (DX) &#x3D; PIC port 1 address<br>        outsb                                   ; output ICW2<br>        IODelay<br>        outsb                                   ; output ICW3<br>        IODelay<br>        outsb                                   ; output ICW4<br>        IODelay<br>        outsb                                   ; output OCW1 (mask register)<br>        IODelay<br>        lodsw<br>        cmp     ax, 0                           ; end of init string?<br>        jne     short Hip10                     ; go init next PIC<br><br>        mov     al, PIC2InitMask                ; save the initial mask in<br>        shl     ax, 8                           ; mask in global variable<br>        mov     al, PIC1InitMask<br>        mov     _HalpGlobal8259Mask, ax<br><br>        mov     al, EnableInterrupts<br>        .if     (al !&#x3D; 0)<br>        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts<br>        .endif<br>        popfd<br>        pop     esi                             ; restore caller&#39;s esi<br>        stdRET    _HalpInitializePICs<br>stdENDP _HalpInitializePICs<br></code></pre></td></tr></table></figure><p>​        我们只需要关心以下两行汇编代码即可，它设置了 8259A 中断控制器主片的 起始中断向量是 0x30，之后设置了从片的起始中断向量是0x38。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">inc     edx                             ; (DX) &#x3D; PIC port 1 address<br>outsb                                   ; output ICW2<br></code></pre></td></tr></table></figure><p>以上代码在2k3的<code>NT\base\hals\halx86\i386\ixirql.asm</code>文件中。如果觉得微软的汇编不好阅读的话，还可以看React-os的代码，它使用c语言编写。代码如下：<br><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153358.png" alt="React-os的代码"></p><p><strong>至此我们可以知道，在使用8259A中断控制器的计算机上，通过IRQ线连接的那15个外设可屏蔽中断是被操作系统线性的映射到了IDT中的一个范围段。在Windows中是0x30-0x40。</strong></p><p>​    使用windbg 查看IDT表，可以看到，window的确将0x30之后分配给了硬件来处理中断，而windows使用了2a-2f 。</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153359.png" alt="IDT表"></p><p>本文写到这里，还是没有讲明白在使用pic的情况下，irq是如何映射到irql的，因为我找不到使用pic的机器了，而所有的虚拟机使用的都是APIC（或许有使用PIC 的虚拟机，但我没有找到）所以我没办法动态调试来逆向这个过程，但我在xp的源码中发现这个定义：</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153400.png" alt="IRQL"></p><p>在查看参考资料时也写着IRQ到IRQL的转换关系是 27 - IRQ，我只能谈就到这里了，下面我们来看一下在使用 APIC 的机器上，IRQ 与 IRQL 的关系。</p><p>写到下面的APIC时查找资料又发现这张图，再次印证上面的说法。</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153401.png" alt="image-20210326144843302"></p><h3 id="APIC-的-IRQ-到-IRQL"><a href="#APIC-的-IRQ-到-IRQL" class="headerlink" title="APIC 的 IRQ 到 IRQL"></a>APIC 的 IRQ 到 IRQL</h3><blockquote><p>事实上，老久的PIC在很早以前就被淘汰了，取而代之的是APIC。由于APIC可以兼容PIC，所以在很多单处理器系统上我们看到的PIC实际是APIC的兼容PIC模式。APIC主要应用于多处理器操作系统，是为了解决IRQ太少和处理器间中断而产生的，当然，单处理器操作系统也可以使用APIC(不是模拟PIC)。APIC的HAL和PIC的HAL有很大的不同，很突出的一个特点就是APIC的HAL不用再象PIC的HAL那样虚拟一个中断控制器，IRQL的概念已经可以通过中断向量的形式被APIC支持。事实上，因为被APIC所支持，所以在APIC HAL里IRQL的实现比PIC HAL那样虚拟一个中断控制器要简单得多了。</p></blockquote><p>这是一篇2002年的帖子，可以看到在那时候PIC就已经被淘汰了，也给了一个安慰我的理由，好像也没有必要对二十多年前一个淘汰的技术刨根问底，(#^.^#)。</p><p>​        整个APIC由几部分组成，一部分是I/O APIC一部分是 LOCAL APIC，还有一个 已经被集成到CPU内部的APIC总线。local apic 是每个处理器都有一个，外部的ioapic 负责接收硬件中断，通过总线通知local apic来处理中断。</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153402.png" alt="APIC"></p><p>​        APIC 和 PIC 一样，是可以编程控制的，只不过它比 pic 先进多了，pci 总线直接给 apic 分配了一个映射的物理地址，本地APIC默认映射到物理地址0xfee00000，IO APIC默认映射到物理地址0xfec00000。windows HAL再进一步把本地APIC映射到虚拟地址0xfffe0000，把IO APIC映射到虚拟地址0xffd06000，也就是说对该地址的读写实际就是对寄存器的读写。</p><p>​        本地APIC里几个重要的寄存有EOI寄存器，任务优先级寄存器(TPR)，处理器优先级寄存器(PPR)，中断命令寄存器(ICR，64位)，中断请求寄存器(IRR，256位，对应每个向量一位)，中断在服务寄存器(ISR，256位)等。</p><p>​        APIC系统支持255个中断向量，但Intel保留了0-15向量，可用的向量是16-255。并引进一个概念叫做任务优先级=中断向量/16，因为保留了16个向量，所以可用的优先级是2-15。当用一个指定的优先级设置本地APIC中的任务优先级寄存器TPR后，所有优先级低于TPR中优先级的中断都被屏蔽，是不是很象IRQL的机制？事实上，APIC HAL里的IRQL机制也就是靠着这个任务优先级寄存器得以实现。</p><p>​        windows 使用中断对象与每个硬件中断进行关联。中断对象结构体如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">kd&gt; dt _kinterrupt<br>nt!_KINTERRUPT<br>   +<span class="hljs-number">0x000</span> Type             : Int2B<br>   +<span class="hljs-number">0x002</span> Size             : Int2B<br>   +<span class="hljs-number">0x004</span> InterruptListEntry : _LIST_ENTRY<br>   +<span class="hljs-number">0x00c</span> ServiceRoutine   : Ptr32     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> <br>   +<span class="hljs-number">0x010</span> ServiceContext   : Ptr32 Void<br>   +<span class="hljs-number">0x014</span> SpinLock         : Uint4B<br>   +<span class="hljs-number">0x018</span> TickCount        : Uint4B<br>   +<span class="hljs-number">0x01c</span> ActualLock       : Ptr32 Uint4B<br>   +<span class="hljs-number">0x020</span> DispatchAddress  : Ptr32     <span class="hljs-keyword">void</span> <br>   +<span class="hljs-number">0x024</span> Vector           : Uint4B<br>   +<span class="hljs-number">0x028</span> Irql             : UChar<br>   +<span class="hljs-number">0x029</span> SynchronizeIrql  : UChar<br>   +<span class="hljs-number">0x02a</span> FloatingSave     : UChar<br>   +<span class="hljs-number">0x02b</span> Connected        : UChar<br>   +<span class="hljs-number">0x02c</span> Number           : Char<br>   +<span class="hljs-number">0x02d</span> ShareVector      : UChar<br>   +<span class="hljs-number">0x030</span> Mode             : _KINTERRUPT_MODE<br>   +<span class="hljs-number">0x034</span> ServiceCount     : Uint4B<br>   +<span class="hljs-number">0x038</span> DispatchCount    : Uint4B<br>   +<span class="hljs-number">0x03c</span> DispatchCode     : [<span class="hljs-number">106</span>] Uint4B<br><br></code></pre></td></tr></table></figure><p>​        其中DispatchCode里面的代码是根据一个模板来的，首先会建立陷阱帧，然后会获取自己所在KINTERRUPT对象地址，得到这两个参数之后，便开始使用 KiInterruptDispatch 或 KiChainedDispatch（如果对该中断注册了多个 KINTERRUPT 结构构成了链表使用此函数）进行中断派遣。而在这两个具体的派遣中都会先调用HalBeginSystemInterrupt，然后才会执行对应中断的实际处理工作，最后会执行HalEndSystemInterrupt完成此次中断处理。下面我们重点来看看这两个函数。</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153403.png" alt="HalBeginSystemInterrupt"></p><p>​        HalBeginSystemInterrupt 通过用IRQL做索引在HalpIRQLtoTPR数组中获取该IRQL对应的任务优先级，用该优先级设置任务优先级寄存器TPR， 设置完TRP 寄存器后，低于这个优先级的中断就会被屏蔽掉。并把TPR中原先的任务优先级/16做为索引在HalpVectorToIRQL数组中获取对应的原先的IRQL然后返回。</p><p>​        接下来做个实验，在HalBeginSystemInterrupt 下断，</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153404.png" alt="image-20210326151135482"></p><p>​    当前 irql 还是 dpc 级别，单步执行到 <code>mov     dword ptr APIC[LU_TPR], eax</code> 之后，当前 irql 已变成 clocl_level。</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210326153405.png" alt="image-20210326151320519"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/wzsy/article/details/51385168">https://blog.csdn.net/wzsy/article/details/51385168</a></li><li><a href="https://blog.csdn.net/lixiangminghate/article/details/51012983">https://blog.csdn.net/lixiangminghate/article/details/51012983</a></li><li><a href="https://www.cnblogs.com/xuanyuan/p/5506508.html">https://www.cnblogs.com/xuanyuan/p/5506508.html</a></li><li><a href="http://blog.sina.com.cn/s/blog_5d29455e0101l562.html">http://blog.sina.com.cn/s/blog_5d29455e0101l562.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows内核</tag>
      
      <tag>irq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆向工程核心指南 读书笔记</title>
    <link href="/2021/03/20/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8C%87%E5%8D%97%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/20/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8C%87%E5%8D%97%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter-5-栈"><a href="#chapter-5-栈" class="headerlink" title="chapter 5:栈"></a>chapter 5:栈</h2><h3 id="栈的增长方向"><a href="#栈的增长方向" class="headerlink" title="栈的增长方向"></a>栈的增长方向</h3><ol><li>在x86体系结构中，栈是逆增长的，指的是 push xxx 这条指令，esp、rsp 的值会减小对应的值，而arm 体系结构中，栈可以是递增也可以是递减的</li><li>栈的逆增长和历史有关，程序中同时存在堆和栈，两者都可以增长，那么具体增长到多少是无法提前确定的，所以将栈设计为逆增长，类似于一个笔记本记录两门课的笔记，一门从前往后去记，一门从后往前记</li></ol><h3 id="栈的用途"><a href="#栈的用途" class="headerlink" title="栈的用途"></a>栈的用途</h3><ol><li>保存函数的返回地址</li><li>参数传递<ol><li>具体参数的地址要根据函数的调用约定来确定</li></ol></li><li>存储局部变量</li><li>alloca函数直接使用栈来分配内存</li><li>windows seh 结构化异常处理</li><li>缓冲区溢出保护</li></ol><h3 id="典型的栈的内存存储格式"><a href="#典型的栈的内存存储格式" class="headerlink" title="典型的栈的内存存储格式"></a>典型的栈的内存存储格式</h3><p>在32位中，在程序调用函数之后，执行它的第一条指令之前，栈在内存中的布局格式如下。</p><table><thead><tr><th>———————-</th><th></th></tr></thead><tbody><tr><td>esp - c</td><td>第二个局部变量，ida中记为var_8</td></tr><tr><td>esp - 8</td><td>第一个局部变量，ida中记为var_4</td></tr><tr><td>esp - 4</td><td>保存的ebp 的值</td></tr><tr><td>esp</td><td>返回地址</td></tr><tr><td>esp + 4</td><td>arg1，ida中记为arg_0</td></tr><tr><td>esp + 8</td><td>arg2，ida中记为arg_4</td></tr><tr><td>esp + c</td><td>arg3，ida中记为arg_8</td></tr></tbody></table><h3 id="栈的对齐粒度"><a href="#栈的对齐粒度" class="headerlink" title="栈的对齐粒度"></a>栈的对齐粒度</h3><ul><li><p>在32位程序中，编译器编译的代码一般对栈是8字节对齐，但在64位程序中，编译器编译出来的代码对栈一般是16字节对齐，一个函数调用另一个函数时，因为压入的8字节返回地址，使本来对齐16字节的栈不对齐了，所以一般在函数开头有使栈对齐16字节的指令</p></li><li><p>[详细解释看这]: <a href="http://www.cpu2.net/stackalign.html">http://www.cpu2.net/stackalign.html</a></p></li></ul><h2 id="chapter-6-参数传递"><a href="#chapter-6-参数传递" class="headerlink" title="chapter 6: 参数传递"></a>chapter 6: 参数传递</h2><h3 id="x86：传递3个参数"><a href="#x86：传递3个参数" class="headerlink" title="x86：传递3个参数"></a>x86：传递3个参数</h3><ol><li>msvc 2010<ol><li>使用push 来向栈中传递参数</li></ol></li><li>gcc 4.4.1<ol><li>先使用sub 来开辟栈空间，再使用mov 来直接操作栈中的数据</li></ol></li></ol><h3 id="x64：传递9个参数测试"><a href="#x64：传递9个参数测试" class="headerlink" title="x64：传递9个参数测试"></a>x64：传递9个参数测试</h3><ol><li><p>msvc 2010  2019</p><ol><li><p>debug <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142923.png"></p></li><li><p>release：这种情况编译器保证传参的位置是对的，不保证传参的顺序，同时使用lea代替mov，表明编译器认为lea执行的比mov更有效率</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142924.png" alt="image-20210106150523272"></p><ul><li><p>在64位中，整形数据只占用4字节空间，但编译器还是为其分配了8字节，不仅是为了方便系统对参数进行寻址，而且编译器会进行地址对齐，所以64位系统为所有数据类型大小小于8字节的类型，都保存8字节空间，同理，32位系统为所有数据类型都保存4字节空间。</p></li><li><p>win64 程序传递参数使用cd89这四个寄存器，超过四个参数的使用栈来传参，并且传递顺序是从右向左依次传参</p></li></ul></li></ol></li><li><p>GCC </p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142925.png" alt="image-20210106152821593"></p><p>*unix 64程序，优先使用 rdi，rsi，rdx，rcx，r8，r9，来传递前六个参数，然后利用栈来传递其余的参数。</p></li></ol><h2 id="chapter-7：全局、局部变量的使用"><a href="#chapter-7：全局、局部变量的使用" class="headerlink" title="chapter 7：全局、局部变量的使用"></a>chapter 7：全局、局部变量的使用</h2><h3 id="案例一：局部变量x"><a href="#案例一：局部变量x" class="headerlink" title="案例一：局部变量x"></a>案例一：局部变量x</h3><h5 id="x32"><a href="#x32" class="headerlink" title="x32"></a>x32</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142926.png" alt="image-20210106154049714" style="zoom: 67%;" /></li><li>x是局部变量，使用lea 得到 x的地址，</li><li>开头的push ecx，在结尾找不到对应的pop ecx，所以并不是保存ecx寄存器的作用，而是开辟了一个4字节的栈空间</li></ul><h6 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h6><ul><li>和msvc类似，只不过传参的时候使用mov 来传参</li></ul><h5 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h5><h6 id="msvc"><a href="#msvc" class="headerlink" title="msvc"></a>msvc</h6><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142927.png" alt="image-20210106154443540" style="zoom:67%;" /><h6 id="gcc-1"><a href="#gcc-1" class="headerlink" title="gcc"></a>gcc</h6><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142928.png" alt="image-20210106154533058" style="zoom:67%;" /><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142929.png" alt="image-20210106154539232" style="zoom:67%;" /><h3 id="案例二：全局变量x"><a href="#案例二：全局变量x" class="headerlink" title="案例二：全局变量x"></a>案例二：全局变量x</h3><ul><li>在linux x86中使用 全局变量是，变量x如果有不为0的初始值，那么编译器会将x存放在data段中，如果初始值为0，编译器会将x放在bss段中</li></ul><h3 id="案例三：对scanf-执行流程的控制"><a href="#案例三：对scanf-执行流程的控制" class="headerlink" title="案例三：对scanf 执行流程的控制"></a>案例三：对scanf 执行流程的控制</h3><h6 id="x32-1"><a href="#x32-1" class="headerlink" title="x32"></a>x32</h6><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142930.png" alt="image-20210106155109552"></li><li>一般来说，条件判断语句会成对的出现 cmp/jcc 汇编指令，cmp会设置标志位，jcc会根据标志位来进行跳转</li></ul><h2 id="chapter-8：参数获取"><a href="#chapter-8：参数获取" class="headerlink" title="chapter 8：参数获取"></a>chapter 8：参数获取</h2><h3 id="x32-2"><a href="#x32-2" class="headerlink" title="x32"></a>x32</h3><h4 id="msvc-1"><a href="#msvc-1" class="headerlink" title="msvc"></a>msvc</h4><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142931.png" alt="image-20210106161458950" style="zoom: 50%;" /></li></ul><h4 id="gcc-2"><a href="#gcc-2" class="headerlink" title="gcc"></a>gcc</h4><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142932.png" alt="image-20210106161520134" style="zoom:50%;" /></li><li>和msvc编译出来的程序大体一致，不过gcc没有使用 mov esp，ebp pop ebp来恢复栈帧，而是使用了leave 一条指令</li></ul><h3 id="x64-1"><a href="#x64-1" class="headerlink" title="x64"></a>x64</h3><h4 id="msvc-2"><a href="#msvc-2" class="headerlink" title="msvc"></a>msvc</h4><ul><li><p>开启优化</p><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142933.png" alt="image-20210106161716202" style="zoom:67%;" /></li></ul></li><li><p>未开启优化</p><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142934.png" alt="image-20210106161915956" style="zoom:67%;" /></li><li>原先位于寄存器中的三个参数先放入到了栈中，在从栈中取出数据进行运算，这个现象叫做 shadow space </li><li>在使用阴影空间时，由调用方函数分配栈空间，被调用函数使用栈空间</li></ul></li></ul><h2 id="chapter-9：返回值"><a href="#chapter-9：返回值" class="headerlink" title="chapter 9：返回值"></a>chapter 9：返回值</h2><p>在x86系统中，被调用方函数通常使用eax来返回运算结果，若返回值是char 或 byte 类型，返回值将存储在eax的低八位，al中，如果返回值是float 浮点数，那么返回值存储在 fpu 的 st(0)寄存器中。</p><h4 id="void型函数的返回值"><a href="#void型函数的返回值" class="headerlink" title="void型函数的返回值"></a>void型函数的返回值</h4><ul><li>在linux 中，如果main函数的类型是void，此时eax的值是最后一个被调用的函数返回的垃圾数据</li><li>在windows 中，msvc 2010，如果main返回void，编译器会将返回值设置为0</li></ul><h4 id="函数返回值不被调用的情况"><a href="#函数返回值不被调用的情况" class="headerlink" title="函数返回值不被调用的情况"></a>函数返回值不被调用的情况</h4><ul><li>返回的结果被抛弃</li></ul><h4 id="返回值为结构体类型的数据"><a href="#返回值为结构体类型的数据" class="headerlink" title="返回值为结构体类型的数据"></a>返回值为结构体类型的数据</h4><ul><li>如果函数的返回值是大型结构的数据，那么由调用方负责分配空间，给结构体分配指针，再将指针作为第一个参数传递给函数。</li></ul><h2 id="chpater-12：条件转移指令"><a href="#chpater-12：条件转移指令" class="headerlink" title="chpater 12：条件转移指令"></a>chpater 12：条件转移指令</h2><h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142935.png" alt="image-20210106164244131" style="zoom: 67%;" /><h5 id="x32-3"><a href="#x32-3" class="headerlink" title="x32"></a>x32</h5><ul><li><h6 id="msvc-3"><a href="#msvc-3" class="headerlink" title="msvc"></a>msvc</h6><ul><li><p>f_signed</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142936.png" alt="image-20210106164820482" style="zoom:67%;" /></li><li><p>第一个条件转移指令是 jle，小于等于时跳转，如果大于，则不跳</p></li><li><p>第二个条件转移指令是 jnz，不等于时跳转，</p></li><li><p>第三个条件转移指令是 jge，大于等于时跳转，</p></li><li><p>这里检查的标志位是“sf xor of”（1 意味着异号） 和zf （1意味着相等）</p></li><li><p>f_unsigned<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142937.png" alt="image-20210106165035187"></p></li><li><p>和f_signed 函数大体相同，只不过条件转移指令使用的是 jbe和 jnb（有可能使用jae）</p></li><li><p>这里跳转指令检查的是 cf （1意味着小于）和 zf（1意味着相等）</p></li></ul><h6 id="gcc-3"><a href="#gcc-3" class="headerlink" title="gcc"></a>gcc</h6><ul><li><p>gcc 在关闭优化的情况下，编译出来的程序与msvc编译出来的程序没什么区别</p><p>但是，在开启优化的情况下，gcc编译出来的指令如下，并且使用jmp替代了 call puts retn这种指令，</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142938.png" alt="image-20210106165700489" style="zoom:67%;" /></li></ul></li></ul><h3 id="计算绝对值"><a href="#计算绝对值" class="headerlink" title="计算绝对值"></a>计算绝对值</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142939.png" alt="image-20210106170021054"></p><h5 id="msvc-x64"><a href="#msvc-x64" class="headerlink" title="msvc x64"></a>msvc x64</h5><ul><li><p>debug</p>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142940.png" alt="image-20210106170349538" style="zoom:67%;" /></li><li><p>release</p>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142941.png" alt="image-20210106170441168" style="zoom:67%;" /></li><li><p>debug下，msvc编译的结果比较繁琐，realease进行了一定的优化</p></li></ul><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142942.png" alt="image-20210106184559226" style="zoom:67%;" /><h5 id="x32-4"><a href="#x32-4" class="headerlink" title="x32"></a>x32</h5><ul><li>早期无优化的编译器将条件运算编译成if/else，代码较复杂，</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142943.png" alt="image-20210106190118699" style="zoom:67%;" /><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142944.png" alt="image-20210106190132445" style="zoom:67%;" /><ul><li>新编译器生成的代较简洁</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142945.png" alt="image-20210106190159976" style="zoom:67%;" /><h5 id="x64-2"><a href="#x64-2" class="headerlink" title="x64"></a>x64</h5><p>msvc</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142946.png" alt="image-20210106190234194" style="zoom:67%;" /><ul><li>使用cmove指令，根据zf标志位决定是否将rdx赋值给rax</li></ul><h3 id="比较最大值和最小值"><a href="#比较最大值和最小值" class="headerlink" title="比较最大值和最小值"></a>比较最大值和最小值</h3><h5 id="x32-5"><a href="#x32-5" class="headerlink" title="x32"></a>x32</h5><ul><li>不启用优化，使用条件转移指令，启用优化，使用cmovcc 指令</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142947.png" alt="image-20210106190847448" style="zoom:67%;" /><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142948.png" alt="image-20210106190855157" style="zoom:67%;" /><h5 id="x64-3"><a href="#x64-3" class="headerlink" title="x64"></a>x64</h5><ul><li>和x32类似</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>条件转移指令构造大体如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">cmp reg1, reg2&#x2F;value<br>jcc true<br>false:<br>some code to be excuted if comparsion is false<br>jmp exit<br>true:<br>some code to be excuted if comparsion is true<br>exit:<br></code></pre></td></tr></table></figure><ul><li>无分支指令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">cmovcc<br></code></pre></td></tr></table></figure><h2 id="chapter-13：switch-case-default"><a href="#chapter-13：switch-case-default" class="headerlink" title="chapter 13：switch/case/default"></a>chapter 13：switch/case/default</h2><h3 id="13-1-case-较少的情况"><a href="#13-1-case-较少的情况" class="headerlink" title="13.1 case 较少的情况"></a>13.1 case 较少的情况</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142949.png" alt="image-20210106191409649"></p><h5 id="x32-6"><a href="#x32-6" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化，msvc 2010</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142950.png" alt="image-20210106191447004" style="zoom:67%;" /><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142951.png" alt="image-20210106191456021" style="zoom:67%;" /><ul><li>开启优化 msvc<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142952.png" alt="image-20210106191940000"><ul><li>将字符串直接赋值给变量后，直接jmp指令调用printf 函数，省略了一次call指令造成的函数返回开销</li></ul></li></ul><h3 id="13-2-case-较多的情况"><a href="#13-2-case-较多的情况" class="headerlink" title="13.2 case 较多的情况"></a>13.2 case 较多的情况</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142953.png" alt="image-20210106192216873" style="zoom:67%;" /><h5 id="x32-7"><a href="#x32-7" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142954.png" alt="image-20210106192430727" style="zoom:67%;" /></li><li>case值连续较多的情况下，会生成一张jmp表，用case的值作为索引</li></ul></li><li>无优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142955.png" alt="image-20210106192554211" style="zoom:67%;" /></li><li>和 msvc 类似，都使用了jmp 表</li></ul></li><li>总结<ul><li>switch中case较多的情况，通常会采取jmp表</li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142956.png" alt="image-20210106192722581" style="zoom:67%;" /></li></ul></li></ul><h3 id="13-3-case-多对一的情况"><a href="#13-3-case-多对一的情况" class="headerlink" title="13.3 case 多对一的情况"></a>13.3 case 多对一的情况</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142957.png" alt="image-20210106192744570" style="zoom:67%;" /><h5 id="msvc-4"><a href="#msvc-4" class="headerlink" title="msvc"></a>msvc</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142958.png" alt="image-20210106192845348" style="zoom:67%;" /></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142959.png" alt="image-20210106192859484" style="zoom:67%;" /></li><li>程序中用到两张表，一张索引表，一张转移表</li><li>程序先根据输入值从索引表中取出索引，再根据索引去转移表中寻找转移的地址</li></ul><h2 id="chapter-14：循环"><a href="#chapter-14：循环" class="headerlink" title="chapter 14：循环"></a>chapter 14：循环</h2><h3 id="14-1-for循环"><a href="#14-1-for循环" class="headerlink" title="14.1 for循环"></a>14.1 for循环</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143000.png" alt="image-20210106193322036" style="zoom:67%;" /><ul><li>msvc 2010 未开启优化<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143001.png" alt="image-20210106193345908" style="zoom:67%;" /></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143002.png" alt="image-20210106193353187" style="zoom:67%;" /></li></ul></li><li>msvc 2010 开启优化<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143003.png" alt="image-20210106193505419" style="zoom:67%;" /></li><li>开启优化后，编译器将局部变量i优化成使用寄存器esi，在局部变量为数不多的情况下，编译器通常会进行这种优化。</li></ul></li><li>总结：<ul><li>循环编译出来的代码一般开始会有一个条件判断，判断循环的条件是否成立，成立之后再执行循环体，循环体执行完后，会跳转到（可能有）对循环变量更改的地方，更改完后会再次判断循环条件是否成立。</li><li>如果编译器能够检测循环语句的初始状态不可能满足循环体的执行条件，那么编译器可能根本不会为循环条件和循环体生成对应的指令</li></ul></li></ul><h3 id="14-2-内存块复制"><a href="#14-2-内存块复制" class="headerlink" title="14.2 内存块复制"></a>14.2 内存块复制</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143004.png" alt="image-20210106194114650"></p><ul><li>gcc x64<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143005.png" alt="image-20210106194140535" style="zoom:67%;" /></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143006.png" alt="image-20210106194145720" style="zoom:67%;" /></li></ul></li></ul><h3 id="14-3-总结"><a href="#14-3-总结" class="headerlink" title="14.3 总结"></a>14.3 总结</h3><ul><li>一般的循环指令格式如下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov [counter], 2<br>jmp check<br>body:<br>;loop body<br>;do something here<br>;user counter value in local stack<br>add [counter], 1<br>check:<br>cmp [counter], 9<br>jle body<br></code></pre></td></tr></table></figure><ul><li>如果没有开启优化选项，那么控制变量递增的语句(add [counter], 1)可能递增为三条指令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov [counter], 2<br>jmp check<br>body:<br>;loop body<br>;do something here<br>; use counter in ebx<br>mov reg, [counter]<br>inc reg<br>mov [couner], reg<br>check:<br>cmp [counter], 9<br>jle body<br></code></pre></td></tr></table></figure><ul><li>当循环体比较短小，或局部变量较少时，编译器可能会给循环条件分配专用的寄存器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ebx, 2<br>jmp check<br>body:<br>;loop body<br>;do something here<br>inc ebx<br>check:<br>cmp ebx, 9<br>jle body<br><br></code></pre></td></tr></table></figure><ul><li>编译器还可能调换部分指令的顺序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov [counter], 2<br>jmp label_check<br>label_increment:<br>add [counter], 1<br>lable_check:<br>cmp [counter], 10<br>jge exit<br>;loop body<br>;do something here<br>jmp label_increment<br>exit:<br></code></pre></td></tr></table></figure><ul><li>通常情况下，程序执行应当首先判断执行条件是否满足，然后再执行循环体，但当编译器能确定第一次迭代肯定会发生的 情况下，它可能会调换循环体语句和判断语句的位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov reg, 2<br>body:<br>;loop body<br>;do something here<br>inc reg<br>cmp reg<br>jl body<br></code></pre></td></tr></table></figure><ul><li>为什么现在编译器都不使用loop语句了？</li></ul><p>循环体语句过于复杂，而loop只会检测ecx寄存器的值是否为0，不为0则递减然后跳转到循环体</p><h2 id="chapter-15：strlen"><a href="#chapter-15：strlen" class="headerlink" title="chapter 15：strlen"></a>chapter 15：strlen</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143007.png" alt="image-20210108162715646"></li></ul><h5 id="x32-8"><a href="#x32-8" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143008.png" alt="image-20210108162754990" style="zoom:67%;" /></li></ul></li><li>无优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143009.png" alt="image-20210108162825818" style="zoom:67%;" /></li><li>setnz al，当zf 为0时，设置al为1</li></ul></li><li>开启优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143010.png" alt="image-20210108162908071" style="zoom:67%;" /></li></ul></li><li>开启优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143011.png" alt="image-20210108162946018" style="zoom:67%;" /></li></ul></li></ul><h5 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143012.png" alt="image-20210108163031836" style="zoom:67%;" /><ul><li><p>```c<br>int count_32(const char * str)<br>{</p><pre><code>int count = 0;if(*str)&#123;    while(*str)&#123;        if (*str++ == 32)            count++;    &#125;&#125;return count;</code></pre><p>}</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> &lt;img src=<span class="hljs-string">&quot;https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143013.png&quot;</span> alt=<span class="hljs-string">&quot;image-20210108163301665&quot;</span> style=<span class="hljs-string">&quot;zoom:67%;&quot;</span> /&gt;</span><br><br><span class="ruby">  - 和上面功能一样</span><br><br><span class="ruby"><span class="hljs-comment">## chapter 16：数学计算指令的替换</span></span><br><br><span class="ruby"><span class="hljs-comment">### 16.1 乘法</span></span><br><br><span class="ruby">- 替换为加法运算</span><br><br><span class="ruby">  - ![image-<span class="hljs-number">20210108163557037</span>](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/gitee.com/zaixiabeiming</span><span class="hljs-regexp">/blog_image/raw</span><span class="hljs-regexp">/master/images</span><span class="hljs-regexp">/20210320143014.png)</span></span><br><br><span class="ruby">- 替换为位移运算</span><br><br><span class="ruby">  - ![image-<span class="hljs-number">20210108163613817</span>](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/gitee.com/zaixiabeiming</span><span class="hljs-regexp">/blog_image/raw</span><span class="hljs-regexp">/master/images</span><span class="hljs-regexp">/20210320143015.png)</span></span><br><br><span class="ruby">- 替换为位移、加法的混合运算</span><br><br><span class="ruby">  - x32</span><br><br><span class="ruby">    - &lt;img src=<span class="hljs-string">&quot;https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143016.png&quot;</span> alt=<span class="hljs-string">&quot;image-20210108163655176&quot;</span> style=<span class="hljs-string">&quot;zoom:67%;&quot;</span> /&gt;</span><br><br><span class="ruby">    - <span class="hljs-string">``</span><span class="hljs-string">`asm</span></span><br><span class="ruby">      ; <span class="hljs-keyword">return</span> a * <span class="hljs-number">7</span></span><br><span class="ruby">      ; ecx = a</span><br><span class="ruby">      mov ecx, dword ptr <span class="hljs-symbol">ds:</span>[esp+<span class="hljs-number">4</span>]</span><br><span class="ruby">      ; eax = ecx * <span class="hljs-number">8</span></span><br><span class="ruby">      lea eax, dword ptr [ecx*<span class="hljs-number">8</span>]</span><br><span class="ruby">      ; eax = eax - ecx = ecx * <span class="hljs-number">8</span> - ecx = ecx * <span class="hljs-number">7</span></span><br><span class="ruby">      sub eax, ecx</span><br></code></pre></td></tr></table></figure><ul><li>```asm<br>; return a * 28<br>mov ecx, dword ptr ds:[esp + 4]<br>lea eax, dword ptr [ecx * 8]<br>sub eax, ecx<br>shl eax, 2<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br>- <span class="hljs-string">```</span>asm<br>  <span class="hljs-comment">; return a * 17</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">esp</span> + <span class="hljs-number">4</span>]<br>  <span class="hljs-keyword">shl</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">4</span><br>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">esp</span> + <span class="hljs-number">4</span>]<br>  <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="16-2-除法运算"><a href="#16-2-除法运算" class="headerlink" title="16.2 除法运算"></a>16.2 除法运算</h3><ul><li><p>替换为位移运算</p><ul><li><pre><code class="asm">; return unsinged int a / 4mov eax, dword ptr ds:[esp + 4]shr eax, 2ret</code></pre></li></ul></li></ul><h3 id="16-3-练习题"><a href="#16-3-练习题" class="headerlink" title="16.3 练习题"></a>16.3 练习题</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143017.png" alt="image-20210108164448768"><ul><li>返回 参数 * 7</li></ul></li></ul><h2 id="chapter-17：FPU"><a href="#chapter-17：FPU" class="headerlink" title="chapter 17：FPU"></a>chapter 17：FPU</h2><h3 id="17-1-浮点数-intel-存储方式"><a href="#17-1-浮点数-intel-存储方式" class="headerlink" title="17.1 浮点数 intel 存储方式"></a>17.1 浮点数 intel 存储方式</h3><p>在x86上，80486处理器问世之前，fpu叫做协、辅助处理器，80486之后，cpu集成了fpu的功能。</p><p>在80486之前，提供的fwait指令，和opcode以d8-df开头的指令，fwait的作用是让cpu等待fpu运算完毕。</p><p>fpu自带一个8个80位寄存器构成的循环栈。这些80位寄存器以ieee 754 格式存储浮点数数据，通常叫做ST(0)-ST(7)寄存器。</p><p>ida和od都把 st(0) 显示为st。不少书籍也将 st(0) 叫做栈顶寄存器</p><h3 id="17-2-浮点数运算"><a href="#17-2-浮点数运算" class="headerlink" title="17.2 浮点数运算"></a>17.2 浮点数运算</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143018.png" alt="image-20210108165211144"></li><li>x32 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143019.png" alt="image-20210108165338437" style="zoom:67%;" /></li><li>指令1执行后：st0寄存器是参数一<ul><li>fld从栈中读取八个字节，并将这个值转换为fpu寄存器的80位格式</li></ul></li><li>指令2执行后：st0寄存器是参数一除以3.14的结果<ul><li>fdiv指令将st0寄存器的值作为被除数，运算之后，st0将保存商</li><li>fdivp指令在运算时，先将st1 st0的值pop之后，运算之后，将结果再push，此时st0将保存商</li></ul></li><li>指令3执行后：st0寄存器是参数二，st1是参数一除以3.14的结果</li><li>指令4执行后：st0寄存器是参数二乘以4.1的结果<ul><li>fmul指令将st0寄存器中的值乘以后面的参数，并将结果保存到st0寄存器中</li></ul></li><li>指令5执行后：st0寄存器就是计算的结果<ul><li>faddp st1，st0 指令计算栈顶两个值的和，先把运算结果存储在st1寄存器，再pop st1。所以运算表达式的结果存储在栈顶的st0寄存器里。</li></ul></li><li>如果一个函数的返回值是一个浮点数，那么返回值约定放在寄存器st0中</li></ul></li><li>x32 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143020.png" alt="image-20210108183828473" style="zoom:67%;" /></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143021.png" alt="image-20210108183834352" style="zoom:67%;" /></li><li>fld 将3.14 加载到寄存器 st0 中</li><li>fdivr 是reverse divide 的缩写，操作数和fdiv 相反，所以此时将 ebp+arg0 作为被除数，将 st0 作为除数</li><li>faddp 将st1 和 st0的值pop出来，计算出的结果再放回st0中</li></ul></li></ul><h3 id="17-3-传递浮点参数"><a href="#17-3-传递浮点参数" class="headerlink" title="17.3 传递浮点参数"></a>17.3 传递浮点参数</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143022.png" alt="image-20210108184227496"></li><li>开辟了两个全局变量来存储参数，传参时先将值加载到寄存器中，然后再写入栈中。（因为汇编指令的操作数不能是立即数？maybe。。。）</li></ul>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DEP原理及ByPass</title>
    <link href="/2021/03/19/DEP%20%E5%8E%9F%E7%90%86%E5%8F%8APass/"/>
    <url>/2021/03/19/DEP%20%E5%8E%9F%E7%90%86%E5%8F%8APass/</url>
    
    <content type="html"><![CDATA[<h4 id="DEP原理"><a href="#DEP原理" class="headerlink" title="DEP原理"></a>DEP原理</h4><ol><li>DEP的基本原理是将数据所在的内存页标识为不可执行，当程序受到攻击，转入执行栈中的shellcode时，程序会尝试在数据页上执行指令，此时 cpu 就会抛出异常，而不是去执行恶意代码。</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163905.png" alt="图 1-1DEP原理"></p><ol start="2"><li>DEP 主要是阻止数据页执行代码，数据页包括栈，堆，以及申请出来的各种不可执行数据页。windows 从 xp sp2开始支持 DEP。</li><li>DEP 分为软件 DEP 和硬件DEP两种，软件的实现是由safeSEH 的一部分，当程序产生异常，转入执行SEH异常处理时，在执行异常处理之前，会检测 SEH处理函数是否位于非可执行页上。KiUserExceptionDispatcher函数大概流程如下。</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163906.png" alt="图 1-2 KiUserExceptionDispatcher"></p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163907.png" alt="图 1-3 RtlDispatchException部分代码"></p><ol start="4"><li>硬件DEP才是真正意义上的DEP，硬件DEP需要 CPU的支持，操作系统在申请数据页时，根据所执行的程序是否开启DEP，来决定数据页虚拟内存所对应的物理页的页属性是否是不可执行。下图是intel 白皮书上，对 xd位的描述。</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163908.png" alt="image-20210319151637214"></p><ol start="4"><li>软件如何开启DEP呢？或者说如何检测一个程序在编译时是否开启了DEP保护呢?答案在PE格式中。开启DEP编译的程序会在文件的PE头中设置IMAGE_DLLCHARACTERISTICS_ NX_COMPAT 标识。</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163909.png" alt="图 1-4 编译软件时开启DEP"></p><ol start="6"><li><p>DEP 的几种状态</p><ol><li><p>Optin：默认仅将 DEP 保护应用于 Windows 系统组件和服务，对于其他程序不予保护，</p><p>但用户可以通过应用程序兼容性工具(ACT，Application Compatibility Toolkit)为选定的程序启用</p><p>DEP，在 Vista 下边经过/NXcompat 选项编译过的程序将自动应用 DEP。这种模式可以被应用</p><p>程序动态关闭，它多用于普通用户版的操作系统，如 Windows XP、Windows Vista、Windows7。</p></li><li><p>Optout：为排除列表程序外的所有程序和服务启用 DEP，用户可以手动在排除列表中</p><p>指定不启用 DEP 保护的程序和服务。这种模式可以被应用程序动态关闭，它多用于服务器版</p><p>的操作系统，如 W indows 2003、Windows 2008。</p></li><li><p>AlwaysOn：对所有进程启用 DEP 的保护，不存在排序列表，在这种模式下，DEP 不</p><p>可以被关闭，目前只有在 64 位的操作系统上才工作在 AlwaysOn 模式。</p></li><li><p>AlwaysOff：对所有进程都禁用 DEP，这种模式下，DEP 也不能被动态开启，这种模</p><p>式一般只有在某种特定场合才使用，如 DEP 干扰到程序的正常运行。</p></li></ol></li><li><p>当 DEP 工作在 Optin 和 Optout 下，是可以使用 API 动态关闭和开启的。</p></li></ol><h3 id="攻击DEP的程序-使用ret2libc"><a href="#攻击DEP的程序-使用ret2libc" class="headerlink" title="攻击DEP的程序-使用ret2libc"></a>攻击DEP的程序-使用ret2libc</h3>]]></content>
    
    
    <categories>
      
      <category>windows漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>DEP</tag>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在调试器中理解计算机系统：acpi</title>
    <link href="/2021/03/19/%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/"/>
    <url>/2021/03/19/%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/</url>
    
    <content type="html"><![CDATA[<h2 id="acpi"><a href="#acpi" class="headerlink" title="acpi"></a>acpi</h2><h3 id="发展缘由"><a href="#发展缘由" class="headerlink" title="发展缘由"></a>发展缘由</h3><p>​        众所周知，现在的电脑有如此多类型，如此多厂家生产的如此多的设备，那么操作系统如何用一套代码来适应数量极其巨大的众多的硬件是一个复杂的问题。acpi 是一种 os 和硬件之间的隔离带。解决了硬件的差异性，为 os访问硬件提供了统一的接口。而acpi 对硬件是有具体的实现。</p><p>​         acpi 不是一蹴而就的，在96年 wintel 就推出了 apm 规范。</p><img src="在调试器中理解计算机系统：acpi/image-20210319093153765.png" alt="image-20210319093153765" style="zoom:50%;" /><p>​        直到 1996年才推出了 acpi 规范。</p><img src="在调试器中理解计算机系统：acpi/image-20210319093238238.png" alt="image-20210319093238238" style="zoom: 80%;" /><h3 id="acpi-：一门编程语言，硬件接口，及电源管理"><a href="#acpi-：一门编程语言，硬件接口，及电源管理" class="headerlink" title="acpi ：一门编程语言，硬件接口，及电源管理"></a>acpi ：一门编程语言，硬件接口，及电源管理</h3><ol><li>acpi 定义了一套脚本语言，叫做 ASL，intel 提供编译器（IASL），编译成字节码（AML），打包进固件里。</li><li>通常由操作系统的驱动程序来解释执行 AML。在 windows 中对应的驱动程序就是 acpi.sys，解释器相关的函数可以通过windbg命令<code>x acpi!*amli*</code>来查看</li><li>ACPI中有对象的概念，有类，方法，数据成员的概念。这些都存放在 ACPI namespace 中。</li><li>ACPI将数据存放在各种表中，每个表中存储一些数据。</li><li>可以使用工具 <code>acpidump -o xxx.bin</code>来 dump acpi数据。</li><li>使用工具<code>acpiextract -a xxx.bin</code>来提取各个表的数据。</li><li>使用工具<code>iasl -d xxx.daat</code>来反编译 AML 字节码，以上几部截图如下</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094400255.png" alt="步骤截图"></p><ol start="8"><li>最经典的  BAT0 电池对象的脚本代码</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094508201.png" alt="电池对象的脚本代码"></p><ol start="9"><li>windbg中也有 AMLI 相关的扩展插件。<code>!amli dns</code>可以dump出 ACPI namespace 中的设备以及方法。</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094623877.png" alt="windbg amli插件"></p><ol start="10"><li>acpi 的架构图</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319093735753.png" alt="ACPI架构图"></p>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>计算机原理</tag>
      
      <tag>acpi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在调试器中理解计算机系统-pci总线：系统的脊梁</title>
    <link href="/2021/03/18/%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Apci%E6%80%BB%E7%BA%BF/"/>
    <url>/2021/03/18/%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Apci%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<ul><li>使用 windbg 打开 dump文件，加载好符号之后使用  !devnode 0 1 列出内核中的设备树</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163934.png" alt="image-20210318160745998"></p><ul><li>浏览输出的结果，最顶级的节点是 HTREE/ROOT ，然后是一级子节点，一级子节点是根据注册表加载的</li><li>在固件中的acpi脚本中，都有pci总线的定义。会触发加载pci的驱动</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163935.png" alt="image-20210318160948498"></p><ul><li>pci驱动初始化时，会枚举pci总线上的设备，为其创建 PDO， 再把 pdo 传递给PnP 服务让其为这个pdo寻找和安装驱动程序。（寻找和安装驱动程序是由PnP的三环服务组件来完成的，安装驱动是根据设备的厂商id和产品id来安装）</li><li>来继续看一下intel的集成显卡设备igfx的设备，搜索igfx找到设备对象</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318162236.png" alt="image-20210318162236324"></p><ul><li>观察设备路径： InstancePath is “PCI\VEN_8086&amp;DEV_0F31&amp;SUBSYS_0F318086&amp;REV_11\3&amp;13c0b0c5&amp;0&amp;10”</li><li>这其中包含了intel的厂商id 8086 ，和这款 gpu的产品id 0F31</li><li>通过 !devnode 8589e4c0 查看详细信息</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163936.png" alt="image-20210318162443044"></p><ul><li>得到 igfx的 pdo， 来看一下这个驱动的设备栈情况，下面是经典的windows 驱动模型 wdm 的设备栈，这四列分别是设备对象，驱动对象，设备扩展，以及对象名</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163937.png" alt="image-20210318162737379"></p><ul><li>可以看到顶层的 igfx设备对象（FDO）和两个acpi过滤设备对象和一个底层的pci设备对象（PDO）</li><li>使用 !DevExt 858980e8 来观察一下 PDO 对象的扩展属性，对于这种 PDO 设备对象， 它的扩展属性里面存储了这个设备的一些信息</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163938.png" alt="image-20210318163849992"></p><ul><li>执行x nt!pnp*，可以观察到NT内核中大量以PnP开头的函数或者全局变量，它们就是内核中的PnP执行体</li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163939.png" alt="image-20210318163907278"></li></ul><ul><li>pci 配置空间结构</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163940.png" alt="image-20210318161618651"></p>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>计算机原理</tag>
      
      <tag>pci</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora+picgo使用gitee图床</title>
    <link href="/2021/03/18/typora-picgo%E4%BD%BF%E7%94%A8gitee%E5%9B%BE%E5%BA%8A/"/>
    <url>/2021/03/18/typora-picgo%E4%BD%BF%E7%94%A8gitee%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<ol><li>gitee 创建仓库并且生成私人令牌</li><li>下载 picgo， 配置令牌，gitee账号，仓库名，仓库路径</li><li>typora 设置图片上传</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318113620.png" alt="image-20210318113022685"></p><p>test</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318113621.png" alt="image-20210318113229506"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo安装与github自动部署</title>
    <link href="/2021/03/10/hexo%E5%AE%89%E8%A3%85%E4%B8%8Egithub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/03/10/hexo%E5%AE%89%E8%A3%85%E4%B8%8Egithub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<ol><li><p>github 创建项目 githubUsername.github.io</p></li><li><p>下载 git</p><ol><li><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></li></ol></li><li><p>ssh 创建公钥，github 用户设置 ssh 添加公钥</p><ol><li><code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></li></ol></li><li><p>然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code></p></li><li><p>打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制</p></li><li><p>测试 <code>ssh -T git@github.com</code></p></li><li><p>安装nodejs</p><ol><li><p><code>npm install stable</code></p></li><li><p> <code>npm install -g hexo-cli</code></p></li></ol></li><li><p>hexo 使用</p><ol><li>创建 blog<ol><li><code>hexo init blogname</code></li><li><code>npm install</code></li></ol></li><li>hexo s 开启本地服务</li><li>hexo g 生成静态页面</li><li>hexo d 部署到github</li></ol></li><li><p>自动部署到github</p><ol><li><p>安装插件</p><ol><li> npm install hexo-deployer-git –save</li></ol></li><li><p>修改配置</p><ol start="2"><li><pre><code class="txt">deploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]</code></pre></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows驱动双机调试环境搭建（串口）</title>
    <link href="/2021/03/10/%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/03/10/%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<ol start="2"><li><ol><li>  虚拟机设置中删除打印机，否则之后的设置调试串口要为2，然后添加串口，使用命名的管道<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210401143517.png" alt="image-20210401142546535"></li></ol></li><li><p>虚拟机内部以管理员权限打开控制台</p><ol><li> 使用当前默认启动设置拷贝一个新的启动项<code>bcdedit /copy &#123;current&#125; /d&quot;windows debug with serial&quot; </code></li><li> 对新生成的启动项启用调试：<code>bcdedit /debug &#123;刚才生成的id&#125; on</code></li><li>设置启动项的调试方法：<code>bcdedit /set &#123;id&#125; debugtype serial</code><ol start="4"><li> <code>bcdedit /set &#123;id&#125; debugport 1</code></li><li> <code>bcdedit /set &#123;id&#125; baudrate 115200</code></li></ol></li><li>设置优先启动     1.  <code>bcdedit /displayorder &#123;current&#125; &#123;id&#125; </code></li></ol></li><li><p>新建一个windbg快捷方式，设置要调试的目标机器和符号路径</p><ul><li>  <code>windbg -k com:pipe,port=\\.\pipe\win_10_1903,resets=0,reconnect -y &quot;srv*D:\03_data\symbols*http://hzxxx2020.ax2401.com:9998/symbols/&quot;</code></li><li>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210402161947.png" alt="image-20210402161940193"></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo资源</title>
    <link href="/2021/03/10/hexo%E8%B5%84%E6%BA%90/"/>
    <url>/2021/03/10/hexo%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><p><a href="https://jiayueshe.github.io/2021/02/17/hello-myblog/">Hello MyBlog | IT 学习 资源 (jiayueshe.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
