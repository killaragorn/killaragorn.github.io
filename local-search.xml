<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>逆向工程核心指南 读书笔记</title>
    <link href="/2021/03/20/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8C%87%E5%8D%97%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/03/20/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8C%87%E5%8D%97%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="chapter-5-栈"><a href="#chapter-5-栈" class="headerlink" title="chapter 5:栈"></a>chapter 5:栈</h2><h3 id="栈的增长方向"><a href="#栈的增长方向" class="headerlink" title="栈的增长方向"></a>栈的增长方向</h3><ol><li>在x86体系结构中，栈是逆增长的，指的是 push xxx 这条指令，esp、rsp 的值会减小对应的值，而arm 体系结构中，栈可以是递增也可以是递减的</li><li>栈的逆增长和历史有关，程序中同时存在堆和栈，两者都可以增长，那么具体增长到多少是无法提前确定的，所以将栈设计为逆增长，类似于一个笔记本记录两门课的笔记，一门从前往后去记，一门从后往前记</li></ol><h3 id="栈的用途"><a href="#栈的用途" class="headerlink" title="栈的用途"></a>栈的用途</h3><ol><li>保存函数的返回地址</li><li>参数传递<ol><li>具体参数的地址要根据函数的调用约定来确定</li></ol></li><li>存储局部变量</li><li>alloca函数直接使用栈来分配内存</li><li>windows seh 结构化异常处理</li><li>缓冲区溢出保护</li></ol><h3 id="典型的栈的内存存储格式"><a href="#典型的栈的内存存储格式" class="headerlink" title="典型的栈的内存存储格式"></a>典型的栈的内存存储格式</h3><p>在32位中，在程序调用函数之后，执行它的第一条指令之前，栈在内存中的布局格式如下。</p><table><thead><tr><th>———————-</th><th></th></tr></thead><tbody><tr><td>esp - c</td><td>第二个局部变量，ida中记为var_8</td></tr><tr><td>esp - 8</td><td>第一个局部变量，ida中记为var_4</td></tr><tr><td>esp - 4</td><td>保存的ebp 的值</td></tr><tr><td>esp</td><td>返回地址</td></tr><tr><td>esp + 4</td><td>arg1，ida中记为arg_0</td></tr><tr><td>esp + 8</td><td>arg2，ida中记为arg_4</td></tr><tr><td>esp + c</td><td>arg3，ida中记为arg_8</td></tr></tbody></table><h3 id="栈的对齐粒度"><a href="#栈的对齐粒度" class="headerlink" title="栈的对齐粒度"></a>栈的对齐粒度</h3><ul><li><p>在32位程序中，编译器编译的代码一般对栈是8字节对齐，但在64位程序中，编译器编译出来的代码对栈一般是16字节对齐，一个函数调用另一个函数时，因为压入的8字节返回地址，使本来对齐16字节的栈不对齐了，所以一般在函数开头有使栈对齐16字节的指令</p></li><li><p>[详细解释看这]: <a href="http://www.cpu2.net/stackalign.html">http://www.cpu2.net/stackalign.html</a></p></li></ul><h2 id="chapter-6-参数传递"><a href="#chapter-6-参数传递" class="headerlink" title="chapter 6: 参数传递"></a>chapter 6: 参数传递</h2><h3 id="x86：传递3个参数"><a href="#x86：传递3个参数" class="headerlink" title="x86：传递3个参数"></a>x86：传递3个参数</h3><ol><li>msvc 2010<ol><li>使用push 来向栈中传递参数</li></ol></li><li>gcc 4.4.1<ol><li>先使用sub 来开辟栈空间，再使用mov 来直接操作栈中的数据</li></ol></li></ol><h3 id="x64：传递9个参数测试"><a href="#x64：传递9个参数测试" class="headerlink" title="x64：传递9个参数测试"></a>x64：传递9个参数测试</h3><ol><li><p>msvc 2010  2019</p><ol><li><p>debug <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142923.png"></p></li><li><p>release：这种情况编译器保证传参的位置是对的，不保证传参的顺序，同时使用lea代替mov，表明编译器认为lea执行的比mov更有效率</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142924.png" alt="image-20210106150523272"></p><ul><li><p>在64位中，整形数据只占用4字节空间，但编译器还是为其分配了8字节，不仅是为了方便系统对参数进行寻址，而且编译器会进行地址对齐，所以64位系统为所有数据类型大小小于8字节的类型，都保存8字节空间，同理，32位系统为所有数据类型都保存4字节空间。</p></li><li><p>win64 程序传递参数使用cd89这四个寄存器，超过四个参数的使用栈来传参，并且传递顺序是从右向左依次传参</p></li></ul></li></ol></li><li><p>GCC </p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142925.png" alt="image-20210106152821593"></p><p>*unix 64程序，优先使用 rdi，rsi，rdx，rcx，r8，r9，来传递前六个参数，然后利用栈来传递其余的参数。</p></li></ol><h2 id="chapter-7：全局、局部变量的使用"><a href="#chapter-7：全局、局部变量的使用" class="headerlink" title="chapter 7：全局、局部变量的使用"></a>chapter 7：全局、局部变量的使用</h2><h3 id="案例一：局部变量x"><a href="#案例一：局部变量x" class="headerlink" title="案例一：局部变量x"></a>案例一：局部变量x</h3><h5 id="x32"><a href="#x32" class="headerlink" title="x32"></a>x32</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142926.png" alt="image-20210106154049714" style="zoom: 67%;" /></li><li>x是局部变量，使用lea 得到 x的地址，</li><li>开头的push ecx，在结尾找不到对应的pop ecx，所以并不是保存ecx寄存器的作用，而是开辟了一个4字节的栈空间</li></ul><h6 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h6><ul><li>和msvc类似，只不过传参的时候使用mov 来传参</li></ul><h5 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h5><h6 id="msvc"><a href="#msvc" class="headerlink" title="msvc"></a>msvc</h6><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142927.png" alt="image-20210106154443540" style="zoom:67%;" /><h6 id="gcc-1"><a href="#gcc-1" class="headerlink" title="gcc"></a>gcc</h6><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142928.png" alt="image-20210106154533058" style="zoom:67%;" /><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142929.png" alt="image-20210106154539232" style="zoom:67%;" /><h3 id="案例二：全局变量x"><a href="#案例二：全局变量x" class="headerlink" title="案例二：全局变量x"></a>案例二：全局变量x</h3><ul><li>在linux x86中使用 全局变量是，变量x如果有不为0的初始值，那么编译器会将x存放在data段中，如果初始值为0，编译器会将x放在bss段中</li></ul><h3 id="案例三：对scanf-执行流程的控制"><a href="#案例三：对scanf-执行流程的控制" class="headerlink" title="案例三：对scanf 执行流程的控制"></a>案例三：对scanf 执行流程的控制</h3><h6 id="x32-1"><a href="#x32-1" class="headerlink" title="x32"></a>x32</h6><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142930.png" alt="image-20210106155109552"></li><li>一般来说，条件判断语句会成对的出现 cmp/jcc 汇编指令，cmp会设置标志位，jcc会根据标志位来进行跳转</li></ul><h2 id="chapter-8：参数获取"><a href="#chapter-8：参数获取" class="headerlink" title="chapter 8：参数获取"></a>chapter 8：参数获取</h2><h3 id="x32-2"><a href="#x32-2" class="headerlink" title="x32"></a>x32</h3><h4 id="msvc-1"><a href="#msvc-1" class="headerlink" title="msvc"></a>msvc</h4><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142931.png" alt="image-20210106161458950" style="zoom: 50%;" /></li></ul><h4 id="gcc-2"><a href="#gcc-2" class="headerlink" title="gcc"></a>gcc</h4><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142932.png" alt="image-20210106161520134" style="zoom:50%;" /></li><li>和msvc编译出来的程序大体一致，不过gcc没有使用 mov esp，ebp pop ebp来恢复栈帧，而是使用了leave 一条指令</li></ul><h3 id="x64-1"><a href="#x64-1" class="headerlink" title="x64"></a>x64</h3><h4 id="msvc-2"><a href="#msvc-2" class="headerlink" title="msvc"></a>msvc</h4><ul><li><p>开启优化</p><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142933.png" alt="image-20210106161716202" style="zoom:67%;" /></li></ul></li><li><p>未开启优化</p><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142934.png" alt="image-20210106161915956" style="zoom:67%;" /></li><li>原先位于寄存器中的三个参数先放入到了栈中，在从栈中取出数据进行运算，这个现象叫做 shadow space </li><li>在使用阴影空间时，由调用方函数分配栈空间，被调用函数使用栈空间</li></ul></li></ul><h2 id="chapter-9：返回值"><a href="#chapter-9：返回值" class="headerlink" title="chapter 9：返回值"></a>chapter 9：返回值</h2><p>在x86系统中，被调用方函数通常使用eax来返回运算结果，若返回值是char 或 byte 类型，返回值将存储在eax的低八位，al中，如果返回值是float 浮点数，那么返回值存储在 fpu 的 st(0)寄存器中。</p><h4 id="void型函数的返回值"><a href="#void型函数的返回值" class="headerlink" title="void型函数的返回值"></a>void型函数的返回值</h4><ul><li>在linux 中，如果main函数的类型是void，此时eax的值是最后一个被调用的函数返回的垃圾数据</li><li>在windows 中，msvc 2010，如果main返回void，编译器会将返回值设置为0</li></ul><h4 id="函数返回值不被调用的情况"><a href="#函数返回值不被调用的情况" class="headerlink" title="函数返回值不被调用的情况"></a>函数返回值不被调用的情况</h4><ul><li>返回的结果被抛弃</li></ul><h4 id="返回值为结构体类型的数据"><a href="#返回值为结构体类型的数据" class="headerlink" title="返回值为结构体类型的数据"></a>返回值为结构体类型的数据</h4><ul><li>如果函数的返回值是大型结构的数据，那么由调用方负责分配空间，给结构体分配指针，再将指针作为第一个参数传递给函数。</li></ul><h2 id="chpater-12：条件转移指令"><a href="#chpater-12：条件转移指令" class="headerlink" title="chpater 12：条件转移指令"></a>chpater 12：条件转移指令</h2><h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142935.png" alt="image-20210106164244131" style="zoom: 67%;" /><h5 id="x32-3"><a href="#x32-3" class="headerlink" title="x32"></a>x32</h5><ul><li><h6 id="msvc-3"><a href="#msvc-3" class="headerlink" title="msvc"></a>msvc</h6><ul><li><p>f_signed</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142936.png" alt="image-20210106164820482" style="zoom:67%;" /></li><li><p>第一个条件转移指令是 jle，小于等于时跳转，如果大于，则不跳</p></li><li><p>第二个条件转移指令是 jnz，不等于时跳转，</p></li><li><p>第三个条件转移指令是 jge，大于等于时跳转，</p></li><li><p>这里检查的标志位是“sf xor of”（1 意味着异号） 和zf （1意味着相等）</p></li><li><p>f_unsigned<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142937.png" alt="image-20210106165035187"></p></li><li><p>和f_signed 函数大体相同，只不过条件转移指令使用的是 jbe和 jnb（有可能使用jae）</p></li><li><p>这里跳转指令检查的是 cf （1意味着小于）和 zf（1意味着相等）</p></li></ul><h6 id="gcc-3"><a href="#gcc-3" class="headerlink" title="gcc"></a>gcc</h6><ul><li><p>gcc 在关闭优化的情况下，编译出来的程序与msvc编译出来的程序没什么区别</p><p>但是，在开启优化的情况下，gcc编译出来的指令如下，并且使用jmp替代了 call puts retn这种指令，</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142938.png" alt="image-20210106165700489" style="zoom:67%;" /></li></ul></li></ul><h3 id="计算绝对值"><a href="#计算绝对值" class="headerlink" title="计算绝对值"></a>计算绝对值</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142939.png" alt="image-20210106170021054"></p><h5 id="msvc-x64"><a href="#msvc-x64" class="headerlink" title="msvc x64"></a>msvc x64</h5><ul><li><p>debug</p>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142940.png" alt="image-20210106170349538" style="zoom:67%;" /></li><li><p>release</p>  <img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142941.png" alt="image-20210106170441168" style="zoom:67%;" /></li><li><p>debug下，msvc编译的结果比较繁琐，realease进行了一定的优化</p></li></ul><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142942.png" alt="image-20210106184559226" style="zoom:67%;" /><h5 id="x32-4"><a href="#x32-4" class="headerlink" title="x32"></a>x32</h5><ul><li>早期无优化的编译器将条件运算编译成if/else，代码较复杂，</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142943.png" alt="image-20210106190118699" style="zoom:67%;" /><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142944.png" alt="image-20210106190132445" style="zoom:67%;" /><ul><li>新编译器生成的代较简洁</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142945.png" alt="image-20210106190159976" style="zoom:67%;" /><h5 id="x64-2"><a href="#x64-2" class="headerlink" title="x64"></a>x64</h5><p>msvc</p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142946.png" alt="image-20210106190234194" style="zoom:67%;" /><ul><li>使用cmove指令，根据zf标志位决定是否将rdx赋值给rax</li></ul><h3 id="比较最大值和最小值"><a href="#比较最大值和最小值" class="headerlink" title="比较最大值和最小值"></a>比较最大值和最小值</h3><h5 id="x32-5"><a href="#x32-5" class="headerlink" title="x32"></a>x32</h5><ul><li>不启用优化，使用条件转移指令，启用优化，使用cmovcc 指令</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142947.png" alt="image-20210106190847448" style="zoom:67%;" /><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142948.png" alt="image-20210106190855157" style="zoom:67%;" /><h5 id="x64-3"><a href="#x64-3" class="headerlink" title="x64"></a>x64</h5><ul><li>和x32类似</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>条件转移指令构造大体如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">cmp reg1, reg2&#x2F;value<br>jcc true<br>false:<br>some code to be excuted if comparsion is false<br>jmp exit<br>true:<br>some code to be excuted if comparsion is true<br>exit:<br></code></pre></td></tr></table></figure><ul><li>无分支指令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">cmovcc<br></code></pre></td></tr></table></figure><h2 id="chapter-13：switch-case-default"><a href="#chapter-13：switch-case-default" class="headerlink" title="chapter 13：switch/case/default"></a>chapter 13：switch/case/default</h2><h3 id="13-1-case-较少的情况"><a href="#13-1-case-较少的情况" class="headerlink" title="13.1 case 较少的情况"></a>13.1 case 较少的情况</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142949.png" alt="image-20210106191409649"></p><h5 id="x32-6"><a href="#x32-6" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化，msvc 2010</li></ul><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142950.png" alt="image-20210106191447004" style="zoom:67%;" /><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142951.png" alt="image-20210106191456021" style="zoom:67%;" /><ul><li>开启优化 msvc<img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142952.png" alt="image-20210106191940000"><ul><li>将字符串直接赋值给变量后，直接jmp指令调用printf 函数，省略了一次call指令造成的函数返回开销</li></ul></li></ul><h3 id="13-2-case-较多的情况"><a href="#13-2-case-较多的情况" class="headerlink" title="13.2 case 较多的情况"></a>13.2 case 较多的情况</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142953.png" alt="image-20210106192216873" style="zoom:67%;" /><h5 id="x32-7"><a href="#x32-7" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142954.png" alt="image-20210106192430727" style="zoom:67%;" /></li><li>case值连续较多的情况下，会生成一张jmp表，用case的值作为索引</li></ul></li><li>无优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142955.png" alt="image-20210106192554211" style="zoom:67%;" /></li><li>和 msvc 类似，都使用了jmp 表</li></ul></li><li>总结<ul><li>switch中case较多的情况，通常会采取jmp表</li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142956.png" alt="image-20210106192722581" style="zoom:67%;" /></li></ul></li></ul><h3 id="13-3-case-多对一的情况"><a href="#13-3-case-多对一的情况" class="headerlink" title="13.3 case 多对一的情况"></a>13.3 case 多对一的情况</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142957.png" alt="image-20210106192744570" style="zoom:67%;" /><h5 id="msvc-4"><a href="#msvc-4" class="headerlink" title="msvc"></a>msvc</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142958.png" alt="image-20210106192845348" style="zoom:67%;" /></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320142959.png" alt="image-20210106192859484" style="zoom:67%;" /></li><li>程序中用到两张表，一张索引表，一张转移表</li><li>程序先根据输入值从索引表中取出索引，再根据索引去转移表中寻找转移的地址</li></ul><h2 id="chapter-14：循环"><a href="#chapter-14：循环" class="headerlink" title="chapter 14：循环"></a>chapter 14：循环</h2><h3 id="14-1-for循环"><a href="#14-1-for循环" class="headerlink" title="14.1 for循环"></a>14.1 for循环</h3><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143000.png" alt="image-20210106193322036" style="zoom:67%;" /><ul><li>msvc 2010 未开启优化<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143001.png" alt="image-20210106193345908" style="zoom:67%;" /></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143002.png" alt="image-20210106193353187" style="zoom:67%;" /></li></ul></li><li>msvc 2010 开启优化<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143003.png" alt="image-20210106193505419" style="zoom:67%;" /></li><li>开启优化后，编译器将局部变量i优化成使用寄存器esi，在局部变量为数不多的情况下，编译器通常会进行这种优化。</li></ul></li><li>总结：<ul><li>循环编译出来的代码一般开始会有一个条件判断，判断循环的条件是否成立，成立之后再执行循环体，循环体执行完后，会跳转到（可能有）对循环变量更改的地方，更改完后会再次判断循环条件是否成立。</li><li>如果编译器能够检测循环语句的初始状态不可能满足循环体的执行条件，那么编译器可能根本不会为循环条件和循环体生成对应的指令</li></ul></li></ul><h3 id="14-2-内存块复制"><a href="#14-2-内存块复制" class="headerlink" title="14.2 内存块复制"></a>14.2 内存块复制</h3><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143004.png" alt="image-20210106194114650"></p><ul><li>gcc x64<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143005.png" alt="image-20210106194140535" style="zoom:67%;" /></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143006.png" alt="image-20210106194145720" style="zoom:67%;" /></li></ul></li></ul><h3 id="14-3-总结"><a href="#14-3-总结" class="headerlink" title="14.3 总结"></a>14.3 总结</h3><ul><li>一般的循环指令格式如下。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov [counter], 2<br>jmp check<br>body:<br>;loop body<br>;do something here<br>;user counter value in local stack<br>add [counter], 1<br>check:<br>cmp [counter], 9<br>jle body<br></code></pre></td></tr></table></figure><ul><li>如果没有开启优化选项，那么控制变量递增的语句(add [counter], 1)可能递增为三条指令。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov [counter], 2<br>jmp check<br>body:<br>;loop body<br>;do something here<br>; use counter in ebx<br>mov reg, [counter]<br>inc reg<br>mov [couner], reg<br>check:<br>cmp [counter], 9<br>jle body<br></code></pre></td></tr></table></figure><ul><li>当循环体比较短小，或局部变量较少时，编译器可能会给循环条件分配专用的寄存器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ebx, 2<br>jmp check<br>body:<br>;loop body<br>;do something here<br>inc ebx<br>check:<br>cmp ebx, 9<br>jle body<br><br></code></pre></td></tr></table></figure><ul><li>编译器还可能调换部分指令的顺序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov [counter], 2<br>jmp label_check<br>label_increment:<br>add [counter], 1<br>lable_check:<br>cmp [counter], 10<br>jge exit<br>;loop body<br>;do something here<br>jmp label_increment<br>exit:<br></code></pre></td></tr></table></figure><ul><li>通常情况下，程序执行应当首先判断执行条件是否满足，然后再执行循环体，但当编译器能确定第一次迭代肯定会发生的 情况下，它可能会调换循环体语句和判断语句的位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov reg, 2<br>body:<br>;loop body<br>;do something here<br>inc reg<br>cmp reg<br>jl body<br></code></pre></td></tr></table></figure><ul><li>为什么现在编译器都不使用loop语句了？</li></ul><p>循环体语句过于复杂，而loop只会检测ecx寄存器的值是否为0，不为0则递减然后跳转到循环体</p><h2 id="chapter-15：strlen"><a href="#chapter-15：strlen" class="headerlink" title="chapter 15：strlen"></a>chapter 15：strlen</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143007.png" alt="image-20210108162715646"></li></ul><h5 id="x32-8"><a href="#x32-8" class="headerlink" title="x32"></a>x32</h5><ul><li>无优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143008.png" alt="image-20210108162754990" style="zoom:67%;" /></li></ul></li><li>无优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143009.png" alt="image-20210108162825818" style="zoom:67%;" /></li><li>setnz al，当zf 为0时，设置al为1</li></ul></li><li>开启优化 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143010.png" alt="image-20210108162908071" style="zoom:67%;" /></li></ul></li><li>开启优化 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143011.png" alt="image-20210108162946018" style="zoom:67%;" /></li></ul></li></ul><h5 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h5><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143012.png" alt="image-20210108163031836" style="zoom:67%;" /><ul><li><p>```c<br>int count_32(const char * str)<br>{</p><pre><code>int count = 0;if(*str)&#123;    while(*str)&#123;        if (*str++ == 32)            count++;    &#125;&#125;return count;</code></pre><p>}</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs haml"><br>-<span class="ruby"> &lt;img src=<span class="hljs-string">&quot;https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143013.png&quot;</span> alt=<span class="hljs-string">&quot;image-20210108163301665&quot;</span> style=<span class="hljs-string">&quot;zoom:67%;&quot;</span> /&gt;</span><br><br><span class="ruby">  - 和上面功能一样</span><br><br><span class="ruby"><span class="hljs-comment">## chapter 16：数学计算指令的替换</span></span><br><br><span class="ruby"><span class="hljs-comment">### 16.1 乘法</span></span><br><br><span class="ruby">- 替换为加法运算</span><br><br><span class="ruby">  - ![image-<span class="hljs-number">20210108163557037</span>](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/gitee.com/zaixiabeiming</span><span class="hljs-regexp">/blog_image/raw</span><span class="hljs-regexp">/master/images</span><span class="hljs-regexp">/20210320143014.png)</span></span><br><br><span class="ruby">- 替换为位移运算</span><br><br><span class="ruby">  - ![image-<span class="hljs-number">20210108163613817</span>](<span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/gitee.com/zaixiabeiming</span><span class="hljs-regexp">/blog_image/raw</span><span class="hljs-regexp">/master/images</span><span class="hljs-regexp">/20210320143015.png)</span></span><br><br><span class="ruby">- 替换为位移、加法的混合运算</span><br><br><span class="ruby">  - x32</span><br><br><span class="ruby">    - &lt;img src=<span class="hljs-string">&quot;https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143016.png&quot;</span> alt=<span class="hljs-string">&quot;image-20210108163655176&quot;</span> style=<span class="hljs-string">&quot;zoom:67%;&quot;</span> /&gt;</span><br><br><span class="ruby">    - <span class="hljs-string">``</span><span class="hljs-string">`asm</span></span><br><span class="ruby">      ; <span class="hljs-keyword">return</span> a * <span class="hljs-number">7</span></span><br><span class="ruby">      ; ecx = a</span><br><span class="ruby">      mov ecx, dword ptr <span class="hljs-symbol">ds:</span>[esp+<span class="hljs-number">4</span>]</span><br><span class="ruby">      ; eax = ecx * <span class="hljs-number">8</span></span><br><span class="ruby">      lea eax, dword ptr [ecx*<span class="hljs-number">8</span>]</span><br><span class="ruby">      ; eax = eax - ecx = ecx * <span class="hljs-number">8</span> - ecx = ecx * <span class="hljs-number">7</span></span><br><span class="ruby">      sub eax, ecx</span><br></code></pre></td></tr></table></figure><ul><li>```asm<br>; return a * 28<br>mov ecx, dword ptr ds:[esp + 4]<br>lea eax, dword ptr [ecx * 8]<br>sub eax, ecx<br>shl eax, 2<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br>- <span class="hljs-string">```</span>asm<br>  <span class="hljs-comment">; return a * 17</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">esp</span> + <span class="hljs-number">4</span>]<br>  <span class="hljs-keyword">shl</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">4</span><br>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">esp</span> + <span class="hljs-number">4</span>]<br>  <span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="16-2-除法运算"><a href="#16-2-除法运算" class="headerlink" title="16.2 除法运算"></a>16.2 除法运算</h3><ul><li><p>替换为位移运算</p><ul><li><pre><code class="asm">; return unsinged int a / 4mov eax, dword ptr ds:[esp + 4]shr eax, 2ret</code></pre></li></ul></li></ul><h3 id="16-3-练习题"><a href="#16-3-练习题" class="headerlink" title="16.3 练习题"></a>16.3 练习题</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143017.png" alt="image-20210108164448768"><ul><li>返回 参数 * 7</li></ul></li></ul><h2 id="chapter-17：FPU"><a href="#chapter-17：FPU" class="headerlink" title="chapter 17：FPU"></a>chapter 17：FPU</h2><h3 id="17-1-浮点数-intel-存储方式"><a href="#17-1-浮点数-intel-存储方式" class="headerlink" title="17.1 浮点数 intel 存储方式"></a>17.1 浮点数 intel 存储方式</h3><p>在x86上，80486处理器问世之前，fpu叫做协、辅助处理器，80486之后，cpu集成了fpu的功能。</p><p>在80486之前，提供的fwait指令，和opcode以d8-df开头的指令，fwait的作用是让cpu等待fpu运算完毕。</p><p>fpu自带一个8个80位寄存器构成的循环栈。这些80位寄存器以ieee 754 格式存储浮点数数据，通常叫做ST(0)-ST(7)寄存器。</p><p>ida和od都把 st(0) 显示为st。不少书籍也将 st(0) 叫做栈顶寄存器</p><h3 id="17-2-浮点数运算"><a href="#17-2-浮点数运算" class="headerlink" title="17.2 浮点数运算"></a>17.2 浮点数运算</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143018.png" alt="image-20210108165211144"></li><li>x32 msvc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143019.png" alt="image-20210108165338437" style="zoom:67%;" /></li><li>指令1执行后：st0寄存器是参数一<ul><li>fld从栈中读取八个字节，并将这个值转换为fpu寄存器的80位格式</li></ul></li><li>指令2执行后：st0寄存器是参数一除以3.14的结果<ul><li>fdiv指令将st0寄存器的值作为被除数，运算之后，st0将保存商</li><li>fdivp指令在运算时，先将st1 st0的值pop之后，运算之后，将结果再push，此时st0将保存商</li></ul></li><li>指令3执行后：st0寄存器是参数二，st1是参数一除以3.14的结果</li><li>指令4执行后：st0寄存器是参数二乘以4.1的结果<ul><li>fmul指令将st0寄存器中的值乘以后面的参数，并将结果保存到st0寄存器中</li></ul></li><li>指令5执行后：st0寄存器就是计算的结果<ul><li>faddp st1，st0 指令计算栈顶两个值的和，先把运算结果存储在st1寄存器，再pop st1。所以运算表达式的结果存储在栈顶的st0寄存器里。</li></ul></li><li>如果一个函数的返回值是一个浮点数，那么返回值约定放在寄存器st0中</li></ul></li><li>x32 gcc<ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143020.png" alt="image-20210108183828473" style="zoom:67%;" /></li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143021.png" alt="image-20210108183834352" style="zoom:67%;" /></li><li>fld 将3.14 加载到寄存器 st0 中</li><li>fdivr 是reverse divide 的缩写，操作数和fdiv 相反，所以此时将 ebp+arg0 作为被除数，将 st0 作为除数</li><li>faddp 将st1 和 st0的值pop出来，计算出的结果再放回st0中</li></ul></li></ul><h3 id="17-3-传递浮点参数"><a href="#17-3-传递浮点参数" class="headerlink" title="17.3 传递浮点参数"></a>17.3 传递浮点参数</h3><ul><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210320143022.png" alt="image-20210108184227496"></li><li>开辟了两个全局变量来存储参数，传参时先将值加载到寄存器中，然后再写入栈中。（因为汇编指令的操作数不能是立即数？maybe。。。）</li></ul>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漏洞利用之 DEP（1）</title>
    <link href="/2021/03/19/DEP%20%E5%8E%9F%E7%90%86%E5%8F%8APass/"/>
    <url>/2021/03/19/DEP%20%E5%8E%9F%E7%90%86%E5%8F%8APass/</url>
    
    <content type="html"><![CDATA[<h4 id="DEP原理"><a href="#DEP原理" class="headerlink" title="DEP原理"></a>DEP原理</h4><ol><li>DEP的基本原理是将数据所在的内存页标识为不可执行，当程序受到攻击，转入执行栈中的shellcode时，程序会尝试在数据页上执行指令，此时 cpu 就会抛出异常，而不是去执行恶意代码。</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163905.png" alt="图 1-1DEP原理"></p><ol start="2"><li>DEP 主要是阻止数据页执行代码，数据页包括栈，堆，以及申请出来的各种不可执行数据页。windows 从 xp sp2开始支持 DEP。</li><li>DEP 分为软件 DEP 和硬件DEP两种，软件的实现是由safeSEH 的一部分，当程序产生异常，转入执行SEH异常处理时，在执行异常处理之前，会检测 SEH处理函数是否位于非可执行页上。KiUserExceptionDispatcher函数大概流程如下。</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163906.png" alt="图 1-2 KiUserExceptionDispatcher"></p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163907.png" alt="图 1-3 RtlDispatchException部分代码"></p><ol start="4"><li>硬件DEP才是真正意义上的DEP，硬件DEP需要 CPU的支持，操作系统在申请数据页时，根据所执行的程序是否开启DEP，来决定数据页虚拟内存所对应的物理页的页属性是否是不可执行。下图是intel 白皮书上，对 xd位的描述。</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163908.png" alt="image-20210319151637214"></p><ol start="4"><li>软件如何开启DEP呢？或者说如何检测一个程序在编译时是否开启了DEP保护呢?答案在PE格式中。开启DEP编译的程序会在文件的PE头中设置IMAGE_DLLCHARACTERISTICS_ NX_COMPAT 标识。</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210319163909.png" alt="图 1-4 编译软件时开启DEP"></p><ol start="6"><li><p>DEP 的几种状态</p><ol><li><p>Optin：默认仅将 DEP 保护应用于 Windows 系统组件和服务，对于其他程序不予保护，</p><p>但用户可以通过应用程序兼容性工具(ACT，Application Compatibility Toolkit)为选定的程序启用</p><p>DEP，在 Vista 下边经过/NXcompat 选项编译过的程序将自动应用 DEP。这种模式可以被应用</p><p>程序动态关闭，它多用于普通用户版的操作系统，如 Windows XP、Windows Vista、Windows7。</p></li><li><p>Optout：为排除列表程序外的所有程序和服务启用 DEP，用户可以手动在排除列表中</p><p>指定不启用 DEP 保护的程序和服务。这种模式可以被应用程序动态关闭，它多用于服务器版</p><p>的操作系统，如 W indows 2003、Windows 2008。</p></li><li><p>AlwaysOn：对所有进程启用 DEP 的保护，不存在排序列表，在这种模式下，DEP 不</p><p>可以被关闭，目前只有在 64 位的操作系统上才工作在 AlwaysOn 模式。</p></li><li><p>AlwaysOff：对所有进程都禁用 DEP，这种模式下，DEP 也不能被动态开启，这种模</p><p>式一般只有在某种特定场合才使用，如 DEP 干扰到程序的正常运行。</p></li></ol></li><li><p>当 DEP 工作在 Optin 和 Optout 下，是可以使用 API 动态关闭和开启的。</p></li></ol><h3 id="攻击DEP的程序-使用ret2libc"><a href="#攻击DEP的程序-使用ret2libc" class="headerlink" title="攻击DEP的程序-使用ret2libc"></a>攻击DEP的程序-使用ret2libc</h3>]]></content>
    
    
    <categories>
      
      <category>windows漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>DEP</tag>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在调试器中理解计算机系统：acpi</title>
    <link href="/2021/03/19/%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/"/>
    <url>/2021/03/19/%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/</url>
    
    <content type="html"><![CDATA[<h2 id="acpi"><a href="#acpi" class="headerlink" title="acpi"></a>acpi</h2><h3 id="发展缘由"><a href="#发展缘由" class="headerlink" title="发展缘由"></a>发展缘由</h3><p>​        众所周知，现在的电脑有如此多类型，如此多厂家生产的如此多的设备，那么操作系统如何用一套代码来适应数量极其巨大的众多的硬件是一个复杂的问题。</p><pre><code>     acpi 是一种 os 和硬件之间的隔离带。解决了硬件的差异性，为 os访问硬件提供了统一的接口。而acpi 对硬件是有具体的实现。</code></pre><p>​         acpi 不是一蹴而就的，在96年 wintel 就推出了 apm 规范。</p><img src="在调试器中理解计算机系统：acpi/image-20210319093153765.png" alt="image-20210319093153765" style="zoom:50%;" /><p>​        直到 1996年才推出了 acpi 规范。</p><img src="在调试器中理解计算机系统：acpi/image-20210319093238238.png" alt="image-20210319093238238" style="zoom: 80%;" /><h3 id="acpi-：一门编程语言，硬件接口，及电源管理"><a href="#acpi-：一门编程语言，硬件接口，及电源管理" class="headerlink" title="acpi ：一门编程语言，硬件接口，及电源管理"></a>acpi ：一门编程语言，硬件接口，及电源管理</h3><ol><li>acpi 定义了一套脚本语言，叫做 ASL，intel 提供编译器（IASL），编译成字节码（AML），打包进固件里。</li><li>通常由操作系统的驱动程序来解释执行 AML。在 windows 中对应的驱动程序就是 acpi.sys，解释器相关的函数可以通过windbg命令<code>x acpi!*amli*</code>来查看</li><li>ACPI中有对象的概念，有类，方法，数据成员的概念。这些都存放在 ACPI namespace 中。</li><li>ACPI将数据存放在各种表中，每个表中存储一些数据。</li><li>可以使用工具 <code>acpidump -o xxx.bin</code>来 dump acpi数据。</li><li>使用工具<code>acpiextract -a xxx.bin</code>来提取各个表的数据。</li><li>使用工具<code>iasl -d xxx.daat</code>来反编译 AML 字节码，以上几部截图如下</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094400255.png" alt="步骤截图"></p><ol start="8"><li>最经典的  BAT0 电池对象的脚本代码</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094508201.png" alt="电池对象的脚本代码"></p><ol start="9"><li>windbg中也有 AMLI 相关的扩展插件。<code>!amli dns</code>可以dump出 ACPI namespace 中的设备以及方法。</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094623877.png" alt="windbg amli插件"></p><ol start="10"><li>acpi 的架构图</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319093735753.png" alt="ACPI架构图"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>计算机原理</tag>
      
      <tag>acpi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在调试器中理解计算机系统-pci总线：系统的脊梁</title>
    <link href="/2021/03/18/2021-03-18-%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Apci%E6%80%BB%E7%BA%BF/"/>
    <url>/2021/03/18/2021-03-18-%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Apci%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<ul><li>使用 windbg 打开 dump文件，加载好符号之后使用  !devnode 0 1 列出内核中的设备树</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163934.png" alt="image-20210318160745998"></p><ul><li>浏览输出的结果，最顶级的节点是 HTREE/ROOT ，然后是一级子节点，一级子节点是根据注册表加载的</li><li>在固件中的acpi脚本中，都有pci总线的定义。会触发加载pci的驱动</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163935.png" alt="image-20210318160948498"></p><ul><li>pci驱动初始化时，会枚举pci总线上的设备，为其创建 PDO， 再把 pdo 传递给PnP 服务让其为这个pdo寻找和安装驱动程序。（寻找和安装驱动程序是由PnP的三环服务组件来完成的，安装驱动是根据设备的厂商id和产品id来安装）</li><li>来继续看一下intel的集成显卡设备igfx的设备，搜索igfx找到设备对象</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318162236.png" alt="image-20210318162236324"></p><ul><li>观察设备路径： InstancePath is “PCI\VEN_8086&amp;DEV_0F31&amp;SUBSYS_0F318086&amp;REV_11\3&amp;13c0b0c5&amp;0&amp;10”</li><li>这其中包含了intel的厂商id 8086 ，和这款 gpu的产品id 0F31</li><li>通过 !devnode 8589e4c0 查看详细信息</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163936.png" alt="image-20210318162443044"></p><ul><li>得到 igfx的 pdo， 来看一下这个驱动的设备栈情况，下面是经典的windows 驱动模型 wdm 的设备栈，这四列分别是设备对象，驱动对象，设备扩展，以及对象名</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163937.png" alt="image-20210318162737379"></p><ul><li>可以看到顶层的 igfx设备对象（FDO）和两个acpi过滤设备对象和一个底层的pci设备对象（PDO）</li><li>使用 !DevExt 858980e8 来观察一下 PDO 对象的扩展属性，对于这种 PDO 设备对象， 它的扩展属性里面存储了这个设备的一些信息</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163938.png" alt="image-20210318163849992"></p><ul><li>执行x nt!pnp*，可以观察到NT内核中大量以PnP开头的函数或者全局变量，它们就是内核中的PnP执行体</li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163939.png" alt="image-20210318163907278"></li></ul><ul><li>pci 配置空间结构</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163940.png" alt="image-20210318161618651"></p>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>计算机原理</tag>
      
      <tag>pci</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora+picgo使用gitee图床</title>
    <link href="/2021/03/18/2021-03-18-typora-picgo%E4%BD%BF%E7%94%A8gitee%E5%9B%BE%E5%BA%8A/"/>
    <url>/2021/03/18/2021-03-18-typora-picgo%E4%BD%BF%E7%94%A8gitee%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<ol><li>gitee 创建仓库并且生成私人令牌</li><li>下载 picgo， 配置令牌，gitee账号，仓库名，仓库路径</li><li>typora 设置图片上传</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318113620.png" alt="image-20210318113022685"></p><p>test</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318113621.png" alt="image-20210318113229506"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo安装与github自动部署</title>
    <link href="/2021/03/10/2021-03-10-hexo%E5%AE%89%E8%A3%85%E4%B8%8Egithub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/03/10/2021-03-10-hexo%E5%AE%89%E8%A3%85%E4%B8%8Egithub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<ol><li><p>github 创建项目 githubUsername.github.io</p></li><li><p>下载 git</p><ol><li><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></li></ol></li><li><p>ssh 创建公钥，github 用户设置 ssh 添加公钥</p><ol><li><code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></li></ol></li><li><p>然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code></p></li><li><p>打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制</p></li><li><p>测试 <code>ssh -T git@github.com</code></p></li><li><p>安装nodejs</p><ol><li><p><code>npm install stable</code></p></li><li><p> <code>npm install -g hexo-cli</code></p></li></ol></li><li><p>hexo 使用</p><ol><li>创建 blog<ol><li><code>hexo init blogname</code></li><li><code>npm install</code></li></ol></li><li>hexo s 开启本地服务</li><li>hexo g 生成静态页面</li><li>hexo d 部署到github</li></ol></li><li><p>自动部署到github</p><ol><li><p>安装插件</p><ol><li> npm install hexo-deployer-git –save</li></ol></li><li><p>修改配置</p><ol start="2"><li><pre><code class="txt">deploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]</code></pre></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo资源</title>
    <link href="/2021/03/10/2021-03-10-hexo%E8%B5%84%E6%BA%90/"/>
    <url>/2021/03/10/2021-03-10-hexo%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><p><a href="https://jiayueshe.github.io/2021/02/17/hello-myblog/">Hello MyBlog | IT 学习 资源 (jiayueshe.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
