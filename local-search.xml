<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>漏洞利用之 DEP（1）</title>
    <link href="/2021/03/19/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8B%20DEP%EF%BC%881%EF%BC%89/"/>
    <url>/2021/03/19/%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8B%20DEP%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h4 id="DEP原理"><a href="#DEP原理" class="headerlink" title="DEP原理"></a>DEP原理</h4><ol><li>DEP的基本原理是将数据所在的内存页标识为不可执行，当程序受到攻击，转入执行栈中的shellcode时，程序会尝试在数据页上执行指令，此时 cpu 就会抛出异常，而不是去执行恶意代码。</li></ol><p><img src="%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BpassDEP/image-20210319141444760.png" alt="图 1-1DEP原理"></p><ol start="2"><li>DEP 主要是阻止数据页执行代码，数据页包括栈，堆，以及申请出来的各种不可执行数据页。windows 从 xp sp2开始支持 DEP。</li><li>DEP 分为软件 DEP 和硬件DEP两种，软件的实现是由safeSEH 的一部分，当程序产生异常，转入执行SEH异常处理时，在执行异常处理之前，会检测 SEH处理函数是否位于非可执行页上。KiUserExceptionDispatcher函数大概流程如下。</li></ol><p><img src="%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BpassDEP/image-20210319142010636.png" alt="图 1-2 KiUserExceptionDispatcher"></p><p><img src="%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BpassDEP/image-20210319142126431.png" alt="图 1-3 RtlDispatchException部分代码"></p><ol start="4"><li>硬件DEP才是真正意义上的DEP，硬件DEP需要 CPU的支持，操作系统在申请数据页时，根据所执行的程序是否开启DEP，来决定数据页虚拟内存所对应的物理页的页属性是否是不可执行。下图是intel 白皮书上，对 xd位的描述。</li></ol><p>![image-20210319151637214](漏洞利用之 DEP（1）/image-20210319151637214.png)</p><ol start="4"><li>软件如何开启DEP呢？或者说如何检测一个程序在编译时是否开启了DEP保护呢?答案在PE格式中。开启DEP编译的程序会在文件的PE头中设置IMAGE_DLLCHARACTERISTICS_ NX_COMPAT 标识。</li></ol><p><img src="%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B9%8BpassDEP/image-20210319142929965.png" alt="图 1-4 编译软件时开启DEP"></p><ol start="6"><li><p>DEP 的几种状态</p><ol><li><p>Optin：默认仅将 DEP 保护应用于 Windows 系统组件和服务，对于其他程序不予保护，</p><p>但用户可以通过应用程序兼容性工具(ACT，Application Compatibility Toolkit)为选定的程序启用</p><p>DEP，在 Vista 下边经过/NXcompat 选项编译过的程序将自动应用 DEP。这种模式可以被应用</p><p>程序动态关闭，它多用于普通用户版的操作系统，如 Windows XP、Windows Vista、Windows7。</p></li><li><p>Optout：为排除列表程序外的所有程序和服务启用 DEP，用户可以手动在排除列表中</p><p>指定不启用 DEP 保护的程序和服务。这种模式可以被应用程序动态关闭，它多用于服务器版</p><p>的操作系统，如 W indows 2003、Windows 2008。</p></li><li><p>AlwaysOn：对所有进程启用 DEP 的保护，不存在排序列表，在这种模式下，DEP 不</p><p>可以被关闭，目前只有在 64 位的操作系统上才工作在 AlwaysOn 模式。</p></li><li><p>AlwaysOff：对所有进程都禁用 DEP，这种模式下，DEP 也不能被动态开启，这种模</p><p>式一般只有在某种特定场合才使用，如 DEP 干扰到程序的正常运行。</p></li></ol></li><li><p>当 DEP 工作在 Optin 和 Optout 下，是可以使用 API 动态关闭和开启的。</p></li></ol><h3 id="攻击未启用DEP的程序"><a href="#攻击未启用DEP的程序" class="headerlink" title="攻击未启用DEP的程序"></a>攻击未启用DEP的程序</h3>]]></content>
    
    
    <categories>
      
      <category>windows漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>DEP</tag>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在调试器中理解计算机系统：acpi</title>
    <link href="/2021/03/19/%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/"/>
    <url>/2021/03/19/%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/</url>
    
    <content type="html"><![CDATA[<h2 id="acpi"><a href="#acpi" class="headerlink" title="acpi"></a>acpi</h2><h3 id="发展缘由"><a href="#发展缘由" class="headerlink" title="发展缘由"></a>发展缘由</h3><p>​        众所周知，现在的电脑有如此多类型，如此多厂家生产的如此多的设备，那么操作系统如何用一套代码来适应数量极其巨大的众多的硬件是一个复杂的问题。</p><pre><code>     acpi 是一种 os 和硬件之间的隔离带。解决了硬件的差异性，为 os访问硬件提供了统一的接口。而acpi 对硬件是有具体的实现。</code></pre><p>​         acpi 不是一蹴而就的，在96年 wintel 就推出了 apm 规范。</p><img src="在调试器中理解计算机系统：acpi/image-20210319093153765.png" alt="image-20210319093153765" style="zoom:50%;" /><p>​        直到 1996年才推出了 acpi 规范。</p><img src="在调试器中理解计算机系统：acpi/image-20210319093238238.png" alt="image-20210319093238238" style="zoom: 80%;" /><h3 id="acpi-：一门编程语言，硬件接口，及电源管理"><a href="#acpi-：一门编程语言，硬件接口，及电源管理" class="headerlink" title="acpi ：一门编程语言，硬件接口，及电源管理"></a>acpi ：一门编程语言，硬件接口，及电源管理</h3><ol><li>acpi 定义了一套脚本语言，叫做 ASL，intel 提供编译器（IASL），编译成字节码（AML），打包进固件里。</li><li>通常由操作系统的驱动程序来解释执行 AML。在 windows 中对应的驱动程序就是 acpi.sys，解释器相关的函数可以通过windbg命令<code>x acpi!*amli*</code>来查看</li><li>ACPI中有对象的概念，有类，方法，数据成员的概念。这些都存放在 ACPI namespace 中。</li><li>ACPI将数据存放在各种表中，每个表中存储一些数据。</li><li>可以使用工具 <code>acpidump -o xxx.bin</code>来 dump acpi数据。</li><li>使用工具<code>acpiextract -a xxx.bin</code>来提取各个表的数据。</li><li>使用工具<code>iasl -d xxx.daat</code>来反编译 AML 字节码，以上几部截图如下</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094400255.png" alt="步骤截图"></p><ol start="8"><li>最经典的  BAT0 电池对象的脚本代码</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094508201.png" alt="电池对象的脚本代码"></p><ol start="9"><li>windbg中也有 AMLI 相关的扩展插件。<code>!amli dns</code>可以dump出 ACPI namespace 中的设备以及方法。</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319094623877.png" alt="windbg amli插件"></p><ol start="10"><li>acpi 的架构图</li></ol><p><img src="%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Aacpi/image-20210319093735753.png" alt="ACPI架构图"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>计算机原理</tag>
      
      <tag>acpi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在调试器中理解计算机系统-pci总线：系统的脊梁</title>
    <link href="/2021/03/18/2021-03-18-%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Apci%E6%80%BB%E7%BA%BF/"/>
    <url>/2021/03/18/2021-03-18-%E5%9C%A8%E8%B0%83%E8%AF%95%E5%99%A8%E4%B8%AD%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%EF%BC%9Apci%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<ul><li>使用 windbg 打开 dump文件，加载好符号之后使用  !devnode 0 1 列出内核中的设备树</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163934.png" alt="image-20210318160745998"></p><ul><li>浏览输出的结果，最顶级的节点是 HTREE/ROOT ，然后是一级子节点，一级子节点是根据注册表加载的</li><li>在固件中的acpi脚本中，都有pci总线的定义。会触发加载pci的驱动</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163935.png" alt="image-20210318160948498"></p><ul><li>pci驱动初始化时，会枚举pci总线上的设备，为其创建 PDO， 再把 pdo 传递给PnP 服务让其为这个pdo寻找和安装驱动程序。（寻找和安装驱动程序是由PnP的三环服务组件来完成的，安装驱动是根据设备的厂商id和产品id来安装）</li><li>来继续看一下intel的集成显卡设备igfx的设备，搜索igfx找到设备对象</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318162236.png" alt="image-20210318162236324"></p><ul><li>观察设备路径： InstancePath is “PCI\VEN_8086&amp;DEV_0F31&amp;SUBSYS_0F318086&amp;REV_11\3&amp;13c0b0c5&amp;0&amp;10”</li><li>这其中包含了intel的厂商id 8086 ，和这款 gpu的产品id 0F31</li><li>通过 !devnode 8589e4c0 查看详细信息</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163936.png" alt="image-20210318162443044"></p><ul><li>得到 igfx的 pdo， 来看一下这个驱动的设备栈情况，下面是经典的windows 驱动模型 wdm 的设备栈，这四列分别是设备对象，驱动对象，设备扩展，以及对象名</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163937.png" alt="image-20210318162737379"></p><ul><li>可以看到顶层的 igfx设备对象（FDO）和两个acpi过滤设备对象和一个底层的pci设备对象（PDO）</li><li>使用 !DevExt 858980e8 来观察一下 PDO 对象的扩展属性，对于这种 PDO 设备对象， 它的扩展属性里面存储了这个设备的一些信息</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163938.png" alt="image-20210318163849992"></p><ul><li>执行x nt!pnp*，可以观察到NT内核中大量以PnP开头的函数或者全局变量，它们就是内核中的PnP执行体</li><li><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163939.png" alt="image-20210318163907278"></li></ul><ul><li>pci 配置空间结构</li></ul><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318163940.png" alt="image-20210318161618651"></p>]]></content>
    
    
    <categories>
      
      <category>windows原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>计算机原理</tag>
      
      <tag>pci</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>typora+picgo使用gitee图床</title>
    <link href="/2021/03/18/2021-03-18-typora-picgo%E4%BD%BF%E7%94%A8gitee%E5%9B%BE%E5%BA%8A/"/>
    <url>/2021/03/18/2021-03-18-typora-picgo%E4%BD%BF%E7%94%A8gitee%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<ol><li>gitee 创建仓库并且生成私人令牌</li><li>下载 picgo， 配置令牌，gitee账号，仓库名，仓库路径</li><li>typora 设置图片上传</li></ol><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318113620.png" alt="image-20210318113022685"></p><p>test</p><p><img src="https://gitee.com/zaixiabeiming/blog_image/raw/master/images/20210318113621.png" alt="image-20210318113229506"></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo安装与github自动部署</title>
    <link href="/2021/03/10/2021-03-10-hexo%E5%AE%89%E8%A3%85%E4%B8%8Egithub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/03/10/2021-03-10-hexo%E5%AE%89%E8%A3%85%E4%B8%8Egithub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<ol><li><p>github 创建项目 githubUsername.github.io</p></li><li><p>下载 git</p><ol><li><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></li></ol></li><li><p>ssh 创建公钥，github 用户设置 ssh 添加公钥</p><ol><li><code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></li></ol></li><li><p>然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code></p></li><li><p>打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制</p></li><li><p>测试 <code>ssh -T git@github.com</code></p></li><li><p>安装nodejs</p><ol><li><p><code>npm install stable</code></p></li><li><p> <code>npm install -g hexo-cli</code></p></li></ol></li><li><p>hexo 使用</p><ol><li>创建 blog<ol><li><code>hexo init blogname</code></li><li><code>npm install</code></li></ol></li><li>hexo s 开启本地服务</li><li>hexo g 生成静态页面</li><li>hexo d 部署到github</li></ol></li><li><p>自动部署到github</p><ol><li><p>安装插件</p><ol><li> npm install hexo-deployer-git –save</li></ol></li><li><p>修改配置</p><ol start="2"><li><pre><code class="txt">deploy:  type: git  repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]</code></pre></li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo资源</title>
    <link href="/2021/03/10/2021-03-10-hexo%E8%B5%84%E6%BA%90/"/>
    <url>/2021/03/10/2021-03-10-hexo%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h2><p><a href="https://jiayueshe.github.io/2021/02/17/hello-myblog/">Hello MyBlog | IT 学习 资源 (jiayueshe.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
